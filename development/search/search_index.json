{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lakefs-spec: An fsspec backend for lakeFS","text":"<p>Early Adopters</p> <p>We are seeking early adopters who would like to actively participate in our feedback process and shape the future of the library. If you are interested in using the library and want to get in touch with us, please reach out via Github Discussions.</p> <p>Welcome to lakeFS-spec, a filesystem-spec backend implementation for the lakeFS data lake. Our primary goal is to streamline versioned data operations in lakeFS, enabling seamless integration with popular data science tools such as Pandas, Polars, and DuckDB directly from Python.</p> <p>Highlights:</p> <ul> <li>High-level abstraction over basic lakeFS repository operations</li> <li>Seamless integration into the fsspec ecosystem</li> <li>Transaction support</li> <li>Zero-config option through config autodiscovery</li> <li>Automatic up-/download management to avoid unnecessary transfers for unchanged files</li> </ul> <p>Quickstart</p><p>Step-by-step installation and first operations</p> <p>Tutorials</p><p>In-depth tutorials on using lakefs-spec</p> <p>API Reference</p><p>Full documentation of the Python API</p> <p>User Guide</p><p>Solving specific tasks with lakefs-spec</p> <p>Contributing</p><p>How to contribute to the project</p>"},{"location":"CONTRIBUTING/","title":"Contributing to lakeFS-spec","text":"<p>Thank you for your interest in contributing to this project!</p> <p>We appreciate issue reports, pull requests for code and documentation, as well as any project-related communication through GitHub Discussions.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<p>To get started with development, you can follow these steps:</p> <ol> <li> <p>Clone this repository:</p> <pre><code>git clone https://github.com/aai-institute/lakefs-spec.git\n</code></pre> </li> <li> <p>Navigate to the directory and install the development dependencies into a virtual environment:</p> <pre><code>cd lakefs-spec\npython3 -m venv venv --system-site-packages\nsource venv/bin/activate\npython -m pip install -r requirements-dev.txt\npython -m pip install -e . --no-deps\n</code></pre> </li> <li> <p>After making your changes, verify they adhere to our Python code style by running <code>pre-commit</code>:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>You can also set up Git hooks through <code>pre-commit</code> to perform these checks automatically:</p> <pre><code>pre-commit install\n</code></pre> </li> <li> <p>To run the tests against an ephemeral lakeFS instance, you just run <code>pytest</code>:     <pre><code>pytest\n</code></pre></p> <p>To spin up a local lakeFS instance quickly for testing, you can use the Docker Compose file bundled with this repository:</p> <pre><code>docker-compose -f hack/docker-compose.yml up\n</code></pre> </li> </ol>"},{"location":"CONTRIBUTING/#updating-dependencies","title":"Updating dependencies","text":"<p>Dependencies should stay locked for as long as possible, ideally for a whole release. If you have to update a dependency during development, you should do the following:</p> <ol> <li>If it is a core dependency needed for the package, add it to the <code>dependencies</code> section in the <code>pyproject.toml</code>.</li> <li>In case of a development dependency, add it to the <code>dev</code> section of the <code>project.optional-dependencies</code> table instead.</li> <li>Dependencies needed for documentation generation are found in the <code>docs</code> sections of <code>project.optional-dependencies</code>.</li> </ol> <p>After adding the dependency in either of these sections, run the helper script <code>hack/lock-deps.sh</code> (which in turn uses <code>pip-compile</code>) to pin all dependencies again:</p> <pre><code>python -m pip install --upgrade pip-tools\nhack/lock-deps.sh\n</code></pre> <p>In addition to these manual steps, we also provide <code>pre-commit</code> hooks that automatically lock the dependencies whenever <code>pyproject.toml</code> is changed.</p> <p>Selective package upgrade for existing dependencies are also handled by the helper script above. If you want to update the <code>lakefs-sdk</code> dependency, for example, simply run:</p> <pre><code>hack/lock-deps.sh lakefs-sdk\n</code></pre> <p>Tip</p> <p>Since the official development version is Python 3.11, please run the above commands in a virtual environment with Python 3.11.</p>"},{"location":"CONTRIBUTING/#working-on-documentation","title":"Working on Documentation","text":"<p>Improvements or additions to the project's documentation are highly appreciated.</p> <p>The documentation is based on the MkDocs and Material for MkDocs (<code>mkdocs-material</code>) projects, see their homepages for in-depth guides on their features and usage. We use the Numpy documentation style for Python docstrings.</p> <p>To build the documentation locally, you need to first install the optional <code>docs</code> dependencies from <code>requirements-docs.txt</code>, e.g., with <code>pip install -r requirements-docs.txt</code>. You can then start a local documentation server with <code>mkdocs serve</code>, or build the documentation into its output folder in <code>public/</code>.</p> <p>In order to maintain documentation for multiple versions of this library, we use the mike tool, which automatically maintains individual documentation builds per version and publishes them to the <code>gh-pages</code> branch.</p> <p>The GitHub CI pipeline automatically invokes <code>mike</code> as part of the release process with the correct version and updates the GitHub pages branch for the project.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Welcome! This quickstart guide will get you up and running with lakeFS-spec by showing you how to</p> <ol> <li>install the <code>lakefs-spec</code> package,</li> <li>spin up a local lakeFS server,</li> <li>create a lakeFS repository for experimentation, and</li> <li>perform basic file system operations in a lakeFS repository using lakeFS-spec.</li> </ol> Prerequisites <p>To follow along with this guide, you will need a few prerequisites ready on your machine:</p> <ul> <li>lakeFS-spec supports Windows, macOS, or Linux</li> <li>Docker, with Docker Compose</li> <li>Python 3.9 or later</li> <li>optionally, <code>lakectl</code>, the lakeFS command line tool</li> </ul> <p>Please take a moment to make sure you have these tools available before proceeding with the next steps.</p>"},{"location":"quickstart/#installing-lakefs-spec","title":"Installing lakeFS-spec","text":"A note on virtual environments <p>We generally recommend installing the library in a virtual environment to ensure proper isolation, especially when following this quickstart guide.</p> <p>If you are using Poetry, virtual environments can automatically be created by the tool.</p> <p>If you prefer the <code>venv</code> functionality built into Python, see the official docs (tl;dr: <code>python -m venv venv; source venv/bin/activate</code>).</p> <p>To install the package directly from PyPI, run:</p> pippoetry <pre><code>pip install lakefs-spec\n</code></pre> <pre><code>poetry add lakefs-spec\n</code></pre> <p>Or, if you want to try the latest pre-release version directly from GitHub:</p> pippoetry <pre><code>pip install git+https://github.com/aai-institute/lakefs-spec.git\n</code></pre> <pre><code>poetry add git+https://github.com/aai-institute/lakefs-spec.git\n</code></pre>"},{"location":"quickstart/#first-steps","title":"First Steps","text":""},{"location":"quickstart/#spinning-up-a-local-lakefs-instance","title":"Spinning up a local lakeFS instance","text":"<p>Warning</p> <p>This setup is not recommended for production uses, since it does not store the data persistently.</p> <p>Please check out the lakeFS docs for production-ready deployment options.</p> <p>If you don't already have access to a lakeFS server, you can quickly start a local instance using Docker Compose. Before continuing, please make sure Docker is installed and running on your machine.</p> <p>The lakeFS quickstart deployment can be launched directly with a configuration file provided in the lakeFS-spec repository:</p> <pre><code>$ curl https://raw.githubusercontent.com/aai-institute/lakefs-spec/main/hack/docker-compose.yml | docker-compose -f - up\n</code></pre> <p>If you do not have <code>curl</code> installed on your machine or would like to examine and/or customize the container configuration, you can also create a <code>docker-compose.yml</code> file locally and use it with <code>docker-compose up</code>:</p> docker-compose.yml<pre><code>version: \"3\"\n\nservices:\n  lakefs:\n    image: treeverse/lakefs:1.3.1\n    ports:\n      - 8000:8000\n    environment:\n      LAKEFS_INSTALLATION_USER_NAME: \"quickstart\"\n      LAKEFS_INSTALLATION_ACCESS_KEY_ID: \"AKIAIOSFOLQUICKSTART\"\n      LAKEFS_INSTALLATION_SECRET_ACCESS_KEY: \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\"\n      LAKEFS_DATABASE_TYPE: \"local\"\n      LAKEFS_AUTH_ENCRYPT_SECRET_KEY: \"THIS_MUST_BE_CHANGED_IN_PRODUCTION\"\n      LAKEFS_BLOCKSTORE_TYPE: \"local\"\n</code></pre> <p>In order to allow lakeFS-spec to automatically discover credentials to access this lakeFS instance, create a <code>.lakectl.yaml</code> in your home directory containing the credentials for the quickstart environment (you can also use <code>lakectl config</code> to create this file interactively if you have the <code>lakectl</code> tool installed on your machine):</p> ~/.lakectl.yaml<pre><code>credentials: # (1)!\n  access_key_id: AKIAIOSFOLQUICKSTART\n  secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nserver:\n  endpoint_url: http://127.0.0.1:8000\n</code></pre> <ol> <li>These must match the credentials set in the <code>environment</code> section of the Docker Compose file above</li> </ol> <p>After the container has finished initializing, you can access the web UI of your local lakeFS deployment in your browser. Fill out the setup form, where you can optionally share your email address with the developers of lakeFS to receive updates on their product. Next, you can log into your fresh lakeFS instance with the credentials listed above.</p> <p>Success</p> <p>Your fresh local lakeFS instance is a playground for you to explore lakeFS functionality. </p> <p>In the next step, we will create your first repository on this server.</p>"},{"location":"quickstart/#create-a-lakefs-repository","title":"Create a lakeFS repository","text":"<p>Once you have logged into the web UI of the lakeFS server for the first time, you can create an empty repository on the next page. Click the small Click here link at the bottom of the page to proceed and create a repository named <code>repo</code> (we don't want to add the sample data for this guide):</p> <p></p> Tip: Creating a repository later <p>If you have inadvertently skipped over the quickstart repository creation page, you can always create a new repository on the Repositories tab in the lakeFS web UI (and optionally choose to add the sample data):</p> <p></p> <p>Success</p> <p>You have successfully created a lakeFS repository named <code>repo</code>, ready to be used with lakeFS-spec.</p>"},{"location":"quickstart/#using-the-lakefs-file-system","title":"Using the lakeFS file system","text":"<p>We will now use the lakeFS-spec file system interface to perform some basic operations on the repository created in the previous step:</p> <ul> <li>Upload a local file to the repository</li> <li>Read data from a file in the repository</li> <li>Make a commit</li> <li>Fetch metadata about repository contents</li> <li>Delete a file from the repository</li> </ul> <p>To get started, create a file called <code>quickstart.py</code> with the following contents:</p> quickstart.py<pre><code>from pathlib import Path\n\nfrom lakefs_spec import LakeFSFileSystem\n\nREPO, BRANCH = \"repo\", \"main\"\n\n# Prepare example local data\nlocal_path = Path(\"demo.txt\")\nlocal_path.write_text(\"Hello, lakeFS!\")\n</code></pre> <p>Tip</p> <p>We will keep adding more code to this file as we progress through the next steps. Feel free to execute the script after each step and observe the effects as noted in the guide.</p> <p>This code snippet prepares a file <code>demo.txt</code> on your machine, ready to be added to the lakeFS repository, so let's do just that:</p> <pre><code>fs = LakeFSFileSystem()  # will auto-discover credentials from ~/.lakectl.yaml\nrepo_path = f\"{REPO}/{BRANCH}/{local_path.name}\"\n\nwith fs.transaction as tx:\n    fs.put(str(local_path), repo_path)\n    tx.commit(REPO, BRANCH, \"Add demo data\")\n</code></pre> <p>If you execute the <code>quickstart.py</code> script at this point, you can already see the committed file in the lakeFS web UI:</p> <p></p> <p>While examining the file contents in the browser is nice, we want to access the committed file programmatically. Add the following lines at the end of your script and observe the output:</p> <pre><code>f = fs.open(repo_path, \"rt\")\nprint(f.readline())  # prints \"Hello, lakeFS!\"\n</code></pre> <p>Note that executing the same code multiple times will only result in a single commit in the repository since the contents of the file on disk and in the repository are identical.</p> <p>In addition to simple read and write operations, the fsspec file system interface also allows us to list the files in a repository folder using <code>ls</code>, and query the metadata of objects in the repository through <code>info</code> (akin to the POSIX <code>stat</code> system call). Let's add the following code to our script and observe the output:</p> <pre><code># Compare the sizes of local file and repo\nfile_info = fs.info(repo_path)\nprint(\n    f\"{local_path.name}: local size: {file_info['size']}, remote size: {local_path.stat().st_size}\"\n)\n\n# Get information about all files in the repo root\nprint(fs.ls(f\"{REPO}/{BRANCH}/\"))\n</code></pre> <p>As the last order of business, let's clean up the repository to its original state by removing the file using the <code>rm</code> operation and creating another commit (also, the local file is deleted, since we don't need it anymore):</p> <pre><code>with fs.transaction as tx:\n    fs.rm(repo_path)\n    tx.commit(REPO, BRANCH, \"Delete demo data\")\nlocal_path.unlink()\n</code></pre> <p>Success</p> <p>You now have all the basic tools available to version data from your Python code using the file system interface provided by lakeFS-spec.</p> Full example code quickstart.py<pre><code>from pathlib import Path\n\nfrom lakefs_spec import LakeFSFileSystem\n\nREPO, BRANCH = \"repo\", \"main\"\n\n# Prepare example local data\nlocal_path = Path(\"demo.txt\")\nlocal_path.write_text(\"Hello, lakeFS!\")\n\n# Upload the local file to the repo and commit\nfs = LakeFSFileSystem()  # will auto-discover credentials from ~/.lakectl.yaml\nrepo_path = f\"{REPO}/{BRANCH}/{local_path.name}\"\n\nwith fs.transaction as tx:\n    fs.put(str(local_path), repo_path)\n    tx.commit(REPO, BRANCH, \"Add demo data\")\n\n# Read back the file contents\nf = fs.open(repo_path, \"rt\")\nprint(f.readline())  # prints \"Hello, lakeFS!\"\n\n# Compare the sizes of local file and repo\nfile_info = fs.info(repo_path)\nprint(\n    f\"{local_path.name}: local size: {file_info['size']}, remote size: {local_path.stat().st_size}\"\n)\n\n# Get information about all files in the repo root\nprint(fs.ls(f\"{REPO}/{BRANCH}/\"))\n\n# Delete uploaded file from the repository (and commit)\nwith fs.transaction as tx:\n    fs.rm(repo_path)\n    tx.commit(REPO, BRANCH, \"Delete demo data\")\nlocal_path.unlink()\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>After this walkthrough of the installation and an introduction to basic file system operations using lakeFS-spec, you might want to consider more advanced topics:</p> <ul> <li>API Reference</li> <li>User Guide, in particular<ul> <li>How to use the lakeFS file system</li> <li>How to use lakeFS-spec with third-party data science libraries</li> </ul> </li> <li>Tutorial: Using lakeFS-spec in a data science project</li> </ul>"},{"location":"guides/","title":"User Guide","text":"<p>The lakeFS-spec user guide provides documentation for users of the library looking to solve specific tasks. See the Quickstart guide for an introductory tutorial.</p> <ul> <li>How to use the lakeFS file system</li> <li>Passing configuration to the file system</li> <li>Using file system transactions</li> <li>Using transactions on the lakeFS file system</li> <li>How to use lakeFS-spec with third-party data science libraries</li> </ul>"},{"location":"guides/configuration/","title":"Passing configuration to the file system","text":"<p>There are multiple ways to configure the <code>LakeFSFileSystem</code> for use with a deployed lakeFS instance. This guide introduces them in the order of least to most in-Python configuration - the preferred way to use the file system is with as little Python code as possible.</p> <p>Info</p> <p>The configuration methods are introduced in reverse order of precedence - config file arguments have the lowest priority and are overwritten by environment variables (if specified).</p>"},{"location":"guides/configuration/#the-lakectlyaml-configuration-file","title":"The <code>.lakectl.yaml</code> configuration file","text":"<p>The easiest way of configuring the lakeFS file system is with a <code>lakectl</code> YAML configuration file. To address a lakeFS server, the following minimum configuration is required:</p> ~/.lakectl.yaml<pre><code>credentials:\n  access_key_id: &lt;ID&gt;\n  secret_access_key: &lt;KEY&gt;\nserver:\n  endpoint_url: &lt;LAKEFS-HOST&gt;\n</code></pre> <p>For a local instance produced by the quickstart, the following values will work:</p> ~/.lakectl.yaml<pre><code>credentials:\n  access_key_id: AKIAIOSFOLQUICKSTART\n  secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nserver:\n  endpoint_url: http://127.0.0.1:8000\n</code></pre> <p>To work without any more arguments \"out of the box\", the configuration file has to be placed in your home directory with the name <code>.lakectl.yaml</code> (this is where lakeFS expects it). If you set all values correctly, you can instantiate the lakeFS file system without any arguments:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\n# zero config necessary.\nfs = LakeFSFileSystem()\n</code></pre> <p>If you cannot use the default location (<code>$HOME/.lakectl.yaml</code>), you can read a file from any other location by passing the <code>configfile</code> argument:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem(configfile=\"/path/to/my/configfile.yaml\")\n</code></pre>"},{"location":"guides/configuration/#setting-environment-variables","title":"Setting environment variables","text":"<p>It is also possible to specify certain configuration values used for authentication with the lakeFS server with environment variables. For these values, the variable name is exactly the constructor argument name prefaced with <code>LAKEFS_</code>, e.g. the <code>host</code> argument can be set via the <code>LAKEFS_HOST</code> environment variable.</p> <pre><code>import os\nfrom lakefs_spec import LakeFSFileSystem\n\nos.environ[\"LAKEFS_HOST\"] = \"http://my-lakefs.host\"\nos.environ[\"LAKEFS_USERNAME\"] = \"my-username\"\nos.environ[\"LAKEFS_PASSWORD\"] = \"my-password\"\n\n# also zero-config.\nfs = LakeFSFileSystem()\n</code></pre> <p>Info</p> <p>Not all initialization values can be set via environment variables - the <code>proxy</code>, <code>create_branch_ok</code>, and <code>source_branch</code> arguments can only be supplied in Python.</p>"},{"location":"guides/configuration/#appendix-mixing-zero-config-methods","title":"Appendix: Mixing zero-config methods","text":"<p>Two of the introduced methods allow for \"zero-config\" (i.e. no arguments given to the constructor) initialization of the file system. However, care must be taken when working with different file systems configured by the same means (for example, file systems configured with separate environment variables).</p> <p>The reason for this is the instance caching mechanism built into fsspec. While this allows for efficient reuse of file systems e.g. by third-party libraries (pandas, DuckDB, ...), it can lead to silent misconfigurations. Consider this example, with an existent <code>.lakectl.yaml</code> file:</p> ~/.lakectl.yaml<pre><code>credentials:\n  access_key_id: AKIAIOSFOLQUICKSTART\n  secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nserver:\n  endpoint_url: http://127.0.0.1:8000\n</code></pre> <p>Now, mixing config file and environment variable initializations leads to the wrong result:</p> <pre><code>import os\nfrom lakefs_spec import LakeFSFileSystem\n\n# first file system, initialized from the config file\nconfig_fs = LakeFSFileSystem()\n\nos.environ[\"LAKEFS_HOST\"] = \"http://my-other-lakefs.host\"\nos.environ[\"LAKEFS_USERNAME\"] = \"my-username\"\nos.environ[\"LAKEFS_PASSWORD\"] = \"my-password\"\n\nenvvar_fs = LakeFSFileSystem()\n\nprint(config_fs is envvar_fs) # &lt;- prints True! \n</code></pre> <p>The reason why the above code does not work as desired is that the cached config-file-initialized file system is simply reused on the second assignment. To clear the file system instance cache, you can run the following:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nLakeFSFileSystem.clear_instance_cache()\n</code></pre>"},{"location":"guides/filesystem-usage/","title":"How to use the lakeFS file system","text":"<p>This guide contains instructions and code snippets on how to use the lakeFS file system.</p>"},{"location":"guides/filesystem-usage/#the-lakefs-uri-structure","title":"The lakeFS URI structure","text":"<p>In the following subsections, we frequently make use of lakeFS URIs in the example code. lakeFS URIs identify resources in a lakeFS deployment through a unique path consisting of repository name, lakeFS revision/ref name, and file name relative to the repository root. Optionally, they may be prefixed with the <code>lakefs://</code> URI scheme (this is required when using third-party libraries).</p> <p>As an example, a URI like <code>repo/main/file.txt</code> addresses the <code>file.txt</code> file on the <code>main</code> branch in the repository named <code>repo</code>.</p> <p>In some lakeFS file system operations, directories are also allowed as resource names. For example, the URI <code>repo/main/data/</code> (note the optional trailing slash) refers to the <code>data</code> directory on the <code>main</code> branch in the <code>repo</code> repository.</p>"},{"location":"guides/filesystem-usage/#on-staged-versus-committed-changes","title":"On staged versus committed changes","text":"<p>When uploading, copying, or removing files or directories from a branch, those removal operations will result in staged changes in the repository until a commit is created. lakeFS-spec does not create these commits automatically, since it separates file operations from versioning operations rigorously. If you want to conduct versioning operations, like creating commits, between file transfers, the best way to do so is by using filesystem transactions.</p>"},{"location":"guides/filesystem-usage/#how-to-use-lakefs-file-system-apis","title":"How to use lakeFS file system APIs","text":"<p>The following section explains more in-depth how to use the <code>LakeFSFileSystem</code> APIs. This section concerns the explicitly implemented operations. In addition, there are a number of file system APIs inherited from the <code>AbstractFileSystem</code> interface in fsspec.</p> <p>More information on file system usage can be found in the fsspec documentation.</p>"},{"location":"guides/filesystem-usage/#uploading-and-downloading-files","title":"Uploading and downloading files","text":"<p>The arguably most important feature of the file system is file transfers.</p>"},{"location":"guides/filesystem-usage/#file-uploads","title":"File uploads","text":"<p>To upload a file, you can use the <code>fs.put()</code> and <code>fs.put_file()</code> methods.  While <code>fs.put_file()</code> operates on single files only, the <code>fs.put()</code> API can be used for directory uploads.</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\n# remote path, then local target path.\nfs.put_file(\"file.txt\", \"my-repo/my-ref/file.txt\")\n</code></pre> <p>If you want to upload an entire directory to lakeFS, you can use the <code>fs.put()</code> API together with the <code>recursive=True</code> switch:</p> <pre><code># structure:\n#   dir/\n#   \u251c\u2500\u2500 a.txt\n#   \u251c\u2500\u2500 b.yaml\n#   \u251c\u2500\u2500 c.csv\n#   \u2514\u2500\u2500 ...\n\nfs.put(\"dir\", \"my-repo/my-ref/dir\", recursive=True)\n</code></pre> <p>Info</p> <p>The above method of file uploading results in two transfers: Once from the client to the lakeFS server, and once from the lakeFS server to the object storage. This can impact performance if the uploaded files are very large. To avoid this performance issue, you can also decide to write the file directly to the underlying object storage:</p> <pre><code>fs = LakeFSFileSystem()\n\nfs.put_file(\"my-repo/my-ref/file.txt\", \"file.txt\", use_blockstore=True)\n</code></pre> <p>Direct lakeFS blockstore uploads require the installation of the corresponding fsspec file system implementation through <code>pip</code>. For an S3-based lakeFS deployment, install the <code>s3fs</code> package. For Google Cloud Storage (GCS), install the <code>gcsfs</code> package. For Azure blob storage, install the <code>adlfs</code> package.</p>"},{"location":"guides/filesystem-usage/#file-downloads","title":"File downloads","text":"<p>To download a file, you can use the <code>fs.get()</code> or <code>fs.get_file()</code> methods. While <code>fs.get_file()</code> downloads single files only, the <code>fs.get()</code> API can be used for recursive directory downloads.</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\n# remote path, then local target path.\nfs.get_file(\"my-repo/my-ref/file.txt\", \"file.txt\")\n</code></pre> <p>In the case of a directory in lakeFS, use the <code>fs.get()</code> API together with the <code>recursive=True</code> switch:</p> <pre><code># structure:\n#   dir/\n#   \u251c\u2500\u2500 a.txt\n#   \u251c\u2500\u2500 b.yaml\n#   \u251c\u2500\u2500 c.csv\n#   \u2514\u2500\u2500 ...\n\n# downloads the entire `dir` directory (and subdirectories) into the current directory.\nfs.get(\"my-repo/my-ref/dir\", \"dir\", recursive=True)\n</code></pre>"},{"location":"guides/filesystem-usage/#checking-the-existence-of-lakefs-objects","title":"Checking the existence of lakeFS objects","text":"<p>To check the existence of a file in a given revision of a repository, you can use the <code>fs.exists()</code> API:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nmy_file_exists = fs.exists(\"my-repo/my-ref/my-file.txt\")\n</code></pre> <p>This function returns <code>True</code> if the file exists on that revision, and <code>False</code> if it does not. Errors (e.g. permission errors) will be raised, since in that case, object existence cannot be decided.</p> <p>Warning</p> <p><code>fs.exists()</code> only works on file objects, and will return <code>False</code> if called on directories.</p>"},{"location":"guides/filesystem-usage/#obtaining-info-on-stored-objects","title":"Obtaining info on stored objects","text":"<p>To query the metadata of a single object in a lakeFS repository, use the <code>fs.info()</code> API:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nmy_file_info = fs.info(\"my-repo/my-ref/my-file.txt\")\n</code></pre> <p>The resulting <code>my_file_info</code> object is a dictionary containing useful information such as storage location of the file, creation timestamp, and size (in bytes).</p> <p>You can also call <code>fs.info()</code> on directories:</p> <pre><code>dir_info = fs.info(\"my-repo/my-ref/dir/\")\n</code></pre> <p>In this case, the resulting <code>dir_info</code> object only contains the directory name, and the cumulated size of the files it contains.</p>"},{"location":"guides/filesystem-usage/#listing-directories-in-lakefs","title":"Listing directories in lakeFS","text":"<p>To list the files in a directory in lakeFS, use the <code>fs.ls()</code> method:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nmy_dir_listing = fs.ls(\"my-repo/my-ref/my-dir/\")\n</code></pre> <p>This returns a list of Python dictionaries containing information on the objects contained in the requested directory. The returned objects have the same fields set as those returned by a normal <code>fs.info()</code> call on a file object.</p>"},{"location":"guides/filesystem-usage/#deleting-objects-from-a-lakefs-branch","title":"Deleting objects from a lakeFS branch","text":"<p>To delete objects from a lakeFS branch, use the <code>fs.rm_file()</code> or <code>fs.rm()</code> APIs. As before, while the former works only for single files, the latter can be used to remove entire directories with the <code>recursive=True</code> option.</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nfs.rm_file(\"my-repo/my-branch/my-file.txt\")\n\n# removes the entire `my-dir` directory.\nfs.rm(\"my-repo/my-branch/my-dir/\", recursive=True)\n</code></pre>"},{"location":"guides/filesystem-usage/#copying-files-in-a-repository","title":"Copying files in a repository","text":"<p>To copy files on a branch or from one branch to another, use the <code>fs.cp_file()</code> or <code>fs.copy()</code> methods:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\n# copies a single file on the same branch to a new location.\nfs.cp_file(\"my-repo/branch-a/file.txt\", \"my-repo/branch-a/file.txt.bak\")\n\n# copies a single file from branch A to branch B.\nfs.cp_file(\"my-repo/branch-a/file.txt\", \"my-repo/branch-b/file.txt\")\n\n# copies the entire `my-dir` directory from branch A to branch B (which must exist).\nfs.copy(\"my-repo/branch-a/my-dir/\", \"my-repo/branch-b/my-dir/\", recursive=True)\n</code></pre> <p>Info</p> <p>Files and directories can only be copied between branches in the same repository, not between different repositories.</p> <p>Trying to copy to a non-existent branch will not create the branch.</p>"},{"location":"guides/integrations/","title":"How to use lakeFS-spec with third-party data science libraries","text":"<p>lakeFS-spec is built on top of the fsspec library, which allows third-party libraries to make use of its file system abstraction to offer high-level features. The fsspec documentation lists examples of its users, mostly data science libraries.</p> <p>This user guide page adds more detail on how lakeFS-spec can be used with four prominent data science libraries.</p> <p>Code Examples</p> <p>The code examples assume access to an existing lakeFS server with a <code>quickstart</code> repository containing the sample data already set up.</p> <p>Please see the Quickstart guide or lakeFS quickstart guide if you need guidance in getting started.</p> <p>The relevant lines for the lakeFS-spec integration in the following code snippets are highlighted.</p>"},{"location":"guides/integrations/#pandas","title":"Pandas","text":"<p>Pandas can read and write data from remote locations, and uses fsspec for all URLs that are not local or HTTP(S).</p> <p>This means that (almost) all <code>pd.read_*</code> and <code>pd.DataFrame.to_*</code> operations can benefit from the lakeFS integration offered by our library without any additional configuration. See the Pandas documentation on reading/writing remote files for additional details.</p> <p>The following code snippet illustrates how to read and write Pandas data frames in various formats from/to a lakeFS repository in the context of a transaction:</p> <pre><code>import pandas as pd\n\nfrom lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nwith fs.transaction as tx:\n    tx.create_branch(\"quickstart\", \"german-lakes\", \"main\")\n\n    lakes = pd.read_parquet(\"lakefs://quickstart/main/lakes.parquet\")\n    german_lakes = lakes.query('Country == \"Germany\"')\n    german_lakes.to_csv(\"lakefs://quickstart/german-lakes/german_lakes.csv\")\n\n    tx.commit(\"quickstart\", \"german-lakes\", \"Add German lakes\")\n</code></pre>"},{"location":"guides/integrations/#duckdb","title":"DuckDB","text":"<p>The DuckDB in-memory database management system includes support for fsspec file systems as part of its Python API (see the official documentation on using fsspec filesystems for details). This allows DuckDB to transparently query and store data located in lakeFS repositories through lakeFS-spec.</p> <p>Similar to the example above, the following code snippet illustrates how to read and write data from/to a lakeFS repository in the context of a transaction through the DuckDB Python API:</p> <pre><code>import duckdb\n\nfrom lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\nduckdb.register_filesystem(fs)\n\nwith fs.transaction as tx:\n    tx.create_branch(\"quickstart\", \"italian-lakes\", \"main\")\n\n    lakes = duckdb.read_parquet(\"lakefs://quickstart/main/lakes.parquet\")\n    italian_lakes = duckdb.sql(\"SELECT * FROM lakes where Country='Italy'\")\n    italian_lakes.to_csv(\"lakefs://quickstart/italian-lakes/italian_lakes.csv\")\n\n    tx.commit(\"quickstart\", \"italian-lakes\", \"Add Italian lakes\")\n</code></pre> <ol> <li>Makes the lakeFS-spec file system known to DuckDB (<code>duckdb.register_filesystem(fsspec.filesystem(\"lakefs\"))</code> can also be used to avoid the direct import of <code>LakeFSFileSystem</code>)</li> </ol>"},{"location":"guides/integrations/#polars","title":"Polars","text":"<p>Warning</p> <p>There is an ongoing discussion in the Polars development team whether to remove support for fsspec file systems, with no clear outcome as of the time this page was written. Please refer to the discussion on the relevant GitHub issue in case you encounter any problems.</p> <p>The Python API wrapper for the Rust-based Polars DataFrame library can access remote storage through fsspec, similar to Pandas (see the official documentation on cloud storage).</p> <p>Again, the following code example demonstrates how to read a Parquet file and save a modified version back in CSV format to a lakeFS repository from Polars in the context of a  transaction:</p> <pre><code>import polars as pl\n\nfrom lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nwith fs.transaction as tx:\n    tx.create_branch(\"quickstart\", \"us-lakes\", \"main\")\n\n    lakes = pl.read_parquet(\"lakefs://quickstart/main/lakes.parquet\")\n    us_lakes = lakes.filter(pl.col(\"Country\") == \"United States of America\")\n\n    with fs.open(\"lakefs://quickstart/us-lakes/us_lakes.csv\", \"wb\") as f:\n        us_lakes.write_csv(f)\n\n    tx.commit(\"quickstart\", \"us-lakes\", \"Add US lakes\")\n</code></pre> <ol> <li>Polars does not support directly writing to remote storage through the <code>pl.DataFrame.write_*</code> API (see docs)</li> </ol>"},{"location":"guides/integrations/#pyarrow","title":"PyArrow","text":"<p>Apache Arrow and its Python API, PyArrow, can also use fsspec file systems to perform I/O operations on data objects. The documentation has additional details on using fsspec-compatible file systems with Arrow.</p> <p>PyArrow <code>read_*</code> and <code>write_*</code> functions take an explicit <code>filesystem</code> parameter, which accepts any fsspec file system, such as the <code>LakeFSFileSystem</code> provided by this library. </p> <p>The following example code illustrates the use of lakeFS-spec with PyArrow, reading a Parquet file and writing it back to a lakeFS repository as a partitioned CSV dataset in the context of a transaction:</p> <pre><code>import pyarrow as pa\nimport pyarrow.dataset as ds\nimport pyarrow.parquet as pq\n\nfrom lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nwith fs.transaction as tx:\n    tx.create_branch(\"quickstart\", \"partitioned-data\", \"main\")\n\n    lakes_table = pq.read_table(\"quickstart/main/lakes.parquet\", filesystem=fs)\n\n    ds.write_dataset(\n        lakes_table,\n        \"quickstart/partitioned-data/lakes\",\n        filesystem=fs,\n        format=\"csv\",\n        partitioning=ds.partitioning(pa.schema([lakes_table.schema.field(\"Country\")])),\n    )\n\n    tx.commit(\"quickstart\", \"partitioned-data\", \"Add partitioned lakes data set\")\n</code></pre>"},{"location":"guides/transactions/","title":"Using transactions on the lakeFS file system","text":"<p>In addition to file operations, you can carry out versioning operations in your Python code using file system transactions.</p> <p>A transaction is basically a context manager that collects all file uploads, defers them, and executes the uploads on completion of the transaction. They are an \"all or nothing\" proposition: If an error occurs during the transaction, none of the queued files are uploaded. For more information on fsspec transactions, see the official documentation.</p> <p>The main features of the lakeFS file system transaction are:</p>"},{"location":"guides/transactions/#atomicity","title":"Atomicity","text":"<p>If an exception occurs anywhere during the transaction, all queued file uploads and versioning operations are discarded:</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nwith fs.transaction as tx:\n    fs.put_file(\"my-file.txt\", \"repo/main/my-file.txt\")\n    tx.commit(\"repo\", \"main\", message=\"Add my-file.txt\")\n    raise ValueError(\"oops!\")\n</code></pre> <p>The above code will not produce a commit on <code>main</code>, since the <code>ValueError</code> prompts a discard of the full upload queue. </p>"},{"location":"guides/transactions/#versioning-helpers","title":"Versioning helpers","text":"<p>The lakeFS file system's transaction is the intended place for conducting versioning operations between file transfers. The following is an example of file uploads with commit creations, with a tag being applied at the end.</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nwith fs.transaction as tx:\n    fs.put_file(\"train-data.txt\", \"repo/main/train-data.txt\")\n    tx.commit(\"repo\", \"main\", message=\"Add training data\")\n    fs.put_file(\"test-data.txt\", \"repo/main/test-data.txt\")\n    sha = tx.commit(\"repo\", \"main\", message=\"Add test data\")\n    tx.tag(\"repo\", sha, tag=\"My train-test split\")\n</code></pre> <p>The full list of supported lakeFS versioning operations:</p> <ul> <li><code>commit</code>, for creating commits on a branch, optionally with attached metadata.</li> <li><code>create_branch</code>, for creating a new branch.</li> <li><code>merge</code>, for merging a given branch into another branch.</li> <li><code>revert</code>, for reverting a previous commit on a branch.</li> <li><code>rev_parse</code>, for parsing revisions like branch/tag names and SHA fragments into full commit SHAs.</li> <li><code>tag</code>, for creating a tag pointing to a commit.</li> </ul> <p>Warning</p> <p>All of the operations above are deferred, and their results are not available until completion of the transaction. For example, the <code>sha</code> return value of <code>tx.commit</code> will be a placeholder for the actual commit SHA computed by the lakeFS server on commit creation.</p> <p>While you can directly use some values (branch/tag names) returned by transaction versioning helpers, care needs to be taken with computed objects like commit SHAs:</p> <pre><code>with fs.transaction as tx:\n    fs.put_file(\"my-file.txt\", \"repo/branch/my-file.txt\")\n    sha = tx.commit(\"repo\", \"branch\", message=\"Add my-file.txt\")\n\n# This will not work: `sha` is of type `Placeholder[Commit]`\nfs.get_file(f\"repo/{sha}/my-file.txt\", \"my-new-file.txt\")\n</code></pre> <p>See the following section on how to reuse commits created during transactions. </p>"},{"location":"guides/transactions/#reusing-resources-created-in-transactions","title":"Reusing resources created in transactions","text":"<p>Some transaction versioning helpers create new objects in the lakeFS instance that are not known before said helpers are actually executed. An example of this is a commit SHA, which is only available once created by the lakeFS server. In the above example, a commit is created directly after a file upload, but its actual SHA identifier will not be available until the transaction is complete. To reuse the value later in your code, you can call <code>unwrap()</code> on the resulting <code>Placeholder</code> object:</p> <pre><code>with fs.transaction as tx:\n    fs.put_file(\"my-file.txt\", \"repo/branch/my-file.txt\")\n    sha = tx.commit(\"repo\", \"branch\", message=\"Add my-file.txt\")\n\n# Obtain the SHA value by unwrapping the placeholder first.\nfs.get_file(f\"repo/{sha.unwrap()}/my-file.txt\", \"my-new-file.txt\")\n</code></pre>"},{"location":"guides/transactions/#thread-safety","title":"Thread safety","text":"<p>Through its use of <code>collections.deque</code> as a store for uploads, upload queueing and file transfers are thread-safe.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>lakefs_spec<ul> <li>client_helpers</li> <li>config</li> <li>errors</li> <li>spec</li> <li>transaction</li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/lakefs_spec/","title":"lakefs_spec","text":"<p>lakefs-spec is an fsspec file system integration for the lakeFS data lake.</p>"},{"location":"reference/lakefs_spec/client_helpers/","title":"client_helpers","text":"<p>This module provides a collection of functions to interact with a lakeFS server using the lakeFS SDK. It includes functionalities to manage branches, repositories, commits, tags, and merge operations in a lakeFS instance.</p> <p>Note: Users of this module should have a configured and authenticated LakeFSClient instance, which is required input to all functions.</p>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.commit","title":"commit","text":"<pre><code>commit(\n    client: LakeFSClient,\n    repository: str,\n    branch: str,\n    message: str,\n    metadata: dict[str, str] | None = None,\n) -&gt; Commit\n</code></pre> <p>Create a new commit of all uncommitted changes on the branch in the lakeFS file storage.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Repository name.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>Branch name.</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>Commit message.</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Additional metadata for the commit.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Commit</code> <p>The created commit object of the lakeFS server.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def commit(\n    client: LakeFSClient,\n    repository: str,\n    branch: str,\n    message: str,\n    metadata: dict[str, str] | None = None,\n) -&gt; Commit:\n    \"\"\"\n    Create a new commit of all uncommitted changes on the branch in the lakeFS file storage.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Repository name.\n    branch: str\n        Branch name.\n    message: str\n        Commit message.\n    metadata: dict[str, str] | None\n        Additional metadata for the commit.\n\n    Returns\n    -------\n    Commit\n        The created commit object of the lakeFS server.\n    \"\"\"\n    diff = client.branches_api.diff_branch(repository=repository, branch=branch)\n\n    if not diff.results:\n        logger.warning(f\"No changes to commit on branch {branch!r}, aborting commit.\")\n        return rev_parse(client, repository, branch, parent=0)\n\n    commit_creation = CommitCreation(message=message, metadata=metadata)\n\n    new_commit = client.commits_api.commit(\n        repository=repository, branch=branch, commit_creation=commit_creation\n    )\n    return new_commit\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.create_branch","title":"create_branch","text":"<pre><code>create_branch(\n    client: LakeFSClient, repository: str, name: str, source_branch: str, exist_ok: bool = True\n) -&gt; str\n</code></pre> <p>Create a branch <code>name</code> in a lakeFS repository.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Repository name.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the branch to be created.</p> <p> TYPE: <code>str</code> </p> <code>source_branch</code> <p>Name of the source branch the new branch is created from.</p> <p> TYPE: <code>str</code> </p> <code>exist_ok</code> <p>Ignore creation errors if the branch already exists.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Name of newly created or existing branch.</p> RAISES DESCRIPTION <code>ApiException</code> <p>If a branch with the same name already exists and <code>exist_ok=False</code>.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def create_branch(\n    client: LakeFSClient, repository: str, name: str, source_branch: str, exist_ok: bool = True\n) -&gt; str:\n    \"\"\"\n    Create a branch ``name`` in a lakeFS repository.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Repository name.\n    name: str\n        Name of the branch to be created.\n    source_branch: str\n        Name of the source branch the new branch is created from.\n    exist_ok: bool\n        Ignore creation errors if the branch already exists.\n\n    Returns\n    -------\n    str\n        Name of newly created or existing branch.\n\n    Raises\n    ------\n    ApiException\n        If a branch with the same name already exists and ``exist_ok=False``.\n    \"\"\"\n\n    try:\n        new_branch = BranchCreation(name=name, source=source_branch)\n        # client.branches_api.create_branch throws ApiException if branch exists\n        client.branches_api.create_branch(repository=repository, branch_creation=new_branch)\n        logger.debug(f\"Created new branch {name!r} from branch {source_branch!r}.\")\n        return name\n    except ApiException as e:\n        if e.status == 409 and exist_ok:\n            return name\n        raise e\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.delete_branch","title":"delete_branch","text":"<pre><code>delete_branch(client: LakeFSClient, repository: str, branch: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete the specified branch from a repository.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository from which the branch will be deleted.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>Name of the branch to be deleted.</p> <p> TYPE: <code>str</code> </p> <code>missing_ok</code> <p>Ignore errors if the requested branch does not exist in the repository.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>NotFoundException</code> <p>If the branch does not exist in the repository and <code>missing_ok=False</code>.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def delete_branch(\n    client: LakeFSClient, repository: str, branch: str, missing_ok: bool = False\n) -&gt; None:\n    \"\"\"\n    Delete the specified branch from a repository.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository from which the branch will be deleted.\n    branch: str\n        Name of the branch to be deleted.\n    missing_ok: bool\n        Ignore errors if the requested branch does not exist in the repository.\n\n    Raises\n    ------\n    NotFoundException\n        If the branch does not exist in the repository and ``missing_ok=False``.\n    \"\"\"\n    try:\n        client.branches_api.delete_branch(repository=repository, branch=branch)\n    except NotFoundException as e:\n        if not missing_ok:\n            raise e\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.list_branches","title":"list_branches","text":"<pre><code>list_branches(client: LakeFSClient, repository: str, prefix: str | None = None) -&gt; list[Ref]\n</code></pre> <p>List branches in a repository.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository for which to list branches.</p> <p> TYPE: <code>str</code> </p> <code>prefix</code> <p>Return branches prefixed with this value.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Ref]</code> <p>A list of qualified branches in the repository.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def list_branches(client: LakeFSClient, repository: str, prefix: str | None = None) -&gt; list[Ref]:\n    \"\"\"\n    List branches in a repository.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository for which to list branches.\n    prefix: str | None\n        Return branches prefixed with this value.\n\n    Returns\n    -------\n    list[Ref]\n        A list of qualified branches in the repository.\n    \"\"\"\n    return list(depaginate(client.branches_api.list_branches, repository=repository, prefix=prefix))\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.create_repository","title":"create_repository","text":"<pre><code>create_repository(\n    client: LakeFSClient, name: str, storage_namespace: str, exist_ok: bool = True\n) -&gt; Repository\n</code></pre> <p>Create a new repository in the lakeFS file storage system with a specified name and storage namespace.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>name</code> <p>Name of the repository to be created. This must be unique within the lakeFS instance.</p> <p> TYPE: <code>str</code> </p> <code>storage_namespace</code> <p>Storage namespace where the repository data will reside, typically corresponding to a bucket in object storage (e.g., S3 bucket) or a local namespace (e.g. local://). <p> TYPE: <code>str</code> </p> <code>exist_ok</code> <p>Ignore creation errors if the repository already exists.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Repository</code> <p>Repository object of the lakeFS SDK representing the newly created or existing repository.</p> RAISES DESCRIPTION <code>ApiException</code> <p>If a repository of the same name already exists and <code>exist_ok=False</code>.</p>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.create_repository--notes","title":"Notes","text":"<p>Attempting to recreate a repository with the same name and storage namespace after previous deletion may lead to issues due to residual data, and is not recommended.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def create_repository(\n    client: LakeFSClient, name: str, storage_namespace: str, exist_ok: bool = True\n) -&gt; Repository:\n    \"\"\"\n    Create a new repository in the lakeFS file storage system with a specified name and storage namespace.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    name: str\n        Name of the repository to be created. This must be unique within the lakeFS instance.\n    storage_namespace: str\n        Storage namespace where the repository data will reside, typically corresponding to a bucket in object storage (e.g., S3 bucket) or a local namespace (e.g. local://&lt;repo_name&gt;).\n    exist_ok: bool\n        Ignore creation errors if the repository already exists.\n\n    Returns\n    -------\n    Repository\n        Repository object of the lakeFS SDK representing the newly created or existing repository.\n\n    Raises\n    ------\n    ApiException\n        If a repository of the same name already exists and ``exist_ok=False``.\n\n    Notes\n    -----\n    Attempting to recreate a repository with the same name and storage namespace after previous deletion may lead to issues due to residual data, and is not recommended.\n    \"\"\"\n    try:\n        repository_creation = RepositoryCreation(name=name, storage_namespace=storage_namespace)\n        return client.repositories_api.create_repository(repository_creation=repository_creation)\n    except ApiException as e:\n        if exist_ok:\n            msg: str = json.loads(e.body)[\"message\"]\n            if e.status == 400 and msg.endswith(\"namespace already in use\") or e.status == 409:\n                return client.repositories_api.get_repository(name)\n        raise e\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.create_tag","title":"create_tag","text":"<pre><code>create_tag(client: LakeFSClient, repository: str, ref: str | Commit, tag: str) -&gt; Ref\n</code></pre> <p>Create a new tag in the specified repository in the lakeFS file storage system.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository where the tag will be created.</p> <p> TYPE: <code>str</code> </p> <code>ref</code> <p>Commit SHA or Commit object of the commit to which the tag will point.</p> <p> TYPE: <code>str | Commit</code> </p> <code>tag</code> <p>Name of the tag to be created.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ApiException</code> <p>If a tag of the same name already exists and points to a different ref.</p> RETURNS DESCRIPTION <code>Ref</code> <p>Ref object of the lakeFS SDK representing the tag.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def create_tag(client: LakeFSClient, repository: str, ref: str | Commit, tag: str) -&gt; Ref:\n    \"\"\"\n    Create a new tag in the specified repository in the lakeFS file storage system.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository where the tag will be created.\n    ref: str | Commit\n        Commit SHA or Commit object of the commit to which the tag will point.\n    tag: str\n        Name of the tag to be created.\n\n    Raises\n    ------\n    ApiException\n        If a tag of the same name already exists and points to a different ref.\n\n    Returns\n    -------\n    Ref\n        Ref object of the lakeFS SDK representing the tag.\n    \"\"\"\n\n    if isinstance(ref, Commit):\n        ref = ref.id\n    tag_creation = TagCreation(id=tag, ref=ref)\n\n    try:\n        return client.tags_api.create_tag(repository=repository, tag_creation=tag_creation)\n    except ApiException as e:\n        if e.status == 409:\n            target_commit = rev_parse(client=client, repository=repository, ref=ref)\n            existing_tag = client.tags_api.get_tag(repository=repository, tag=tag)\n            if existing_tag.commit_id == target_commit.id:\n                return existing_tag\n        raise e\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.delete_tag","title":"delete_tag","text":"<pre><code>delete_tag(client: LakeFSClient, repository: str, tag: str | Ref) -&gt; None\n</code></pre> <p>Delete the specified tag from a repository.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository from which the tag will be deleted.</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>Tag to be deleted.</p> <p> TYPE: <code>str | Ref</code> </p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def delete_tag(client: LakeFSClient, repository: str, tag: str | Ref) -&gt; None:\n    \"\"\"\n    Delete the specified tag from a repository.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository from which the tag will be deleted.\n    tag: str | Ref\n        Tag to be deleted.\n    \"\"\"\n    if isinstance(tag, Ref):\n        tag = tag.id\n    client.tags_api.delete_tag(repository=repository, tag=tag)\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.list_tags","title":"list_tags","text":"<pre><code>list_tags(client: LakeFSClient, repository: str) -&gt; list[Ref]\n</code></pre> <p>List all the tags in the specified repository in the lakeFS file storage system.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository from which to list the tags.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Ref]</code> <p>Ref objects of the tag in the repository.</p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def list_tags(client: LakeFSClient, repository: str) -&gt; list[Ref]:\n    \"\"\"\n    List all the tags in the specified repository in the lakeFS file storage system.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository from which to list the tags.\n\n    Returns\n    -------\n    list[Ref]\n        Ref objects of the tag in the repository.\n    \"\"\"\n    return list(depaginate(client.tags_api.list_tags, repository))\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.merge","title":"merge","text":"<pre><code>merge(client: LakeFSClient, repository: str, source_ref: str, target_branch: str) -&gt; None\n</code></pre> <p>Merges changes from a source reference to a target branch in a specified repository in the lakeFS file storage system. If no differences between source_ref and target_branch are found, the merge process is aborted.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository where the merge will occur.</p> <p> TYPE: <code>str</code> </p> <code>source_ref</code> <p>Source reference (branch name or ref/commit SHA) from which changes will be merged.</p> <p> TYPE: <code>str</code> </p> <code>target_branch</code> <p>Target branch to which changes will be merged.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def merge(client: LakeFSClient, repository: str, source_ref: str, target_branch: str) -&gt; None:\n    \"\"\"\n    Merges changes from a source reference to a target branch in a specified repository in the lakeFS file storage system.\n    If no differences between source_ref and target_branch are found, the merge process is aborted.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository where the merge will occur.\n    source_ref: str\n        Source reference (branch name or ref/commit SHA) from which changes will be merged.\n    target_branch: str\n        Target branch to which changes will be merged.\n    \"\"\"\n    diff = client.refs_api.diff_refs(\n        repository=repository, left_ref=target_branch, right_ref=source_ref\n    )\n    if not diff.results:\n        logger.warning(\"No difference between source and target. Aborting merge.\")\n        return\n    client.refs_api.merge_into_branch(\n        repository=repository, source_ref=source_ref, destination_branch=target_branch\n    )\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.revert","title":"revert","text":"<pre><code>revert(client: LakeFSClient, repository: str, branch: str, parent_number: int = 1) -&gt; None\n</code></pre> <p>Revert the commit on the specified branch to the parent specified by parent_number.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Repository in which the specified branch is located.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>Branch on which the commit should be reverted.</p> <p> TYPE: <code>str</code> </p> <code>parent_number</code> <p>If there are multiple parents to a commit, specify to which parent the commit should be reverted. <code>parent_number = 1</code> (the default)  refers to the first parent commit of the current <code>branch</code> tip.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def revert(client: LakeFSClient, repository: str, branch: str, parent_number: int = 1) -&gt; None:\n    \"\"\"\n    Revert the commit on the specified branch to the parent specified by parent_number.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Repository in which the specified branch is located.\n    branch: str\n        Branch on which the commit should be reverted.\n    parent_number: int, optional\n        If there are multiple parents to a commit, specify to which parent the commit should be reverted.\n        ``parent_number = 1`` (the default)  refers to the first parent commit of the current ``branch`` tip.\n    \"\"\"\n    revert_creation = RevertCreation(ref=branch, parent_number=parent_number)\n    client.branches_api.revert_branch(\n        repository=repository, branch=branch, revert_creation=revert_creation\n    )\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.reset_branch","title":"reset_branch","text":"<pre><code>reset_branch(client: LakeFSClient, repository: str, branch: str) -&gt; None\n</code></pre> <p>Reset the specified branch to its head.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Repository in which the specified branch is located.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>Branch to reset.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def reset_branch(client: LakeFSClient, repository: str, branch: str) -&gt; None:\n    \"\"\"\n    Reset the specified branch to its head.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Repository in which the specified branch is located.\n    branch: str\n        Branch to reset.\n    \"\"\"\n    reset_creation = ResetCreation(type=\"reset\")\n    client.branches_api.reset_branch(\n        repository=repository, branch=branch, reset_creation=reset_creation\n    )\n</code></pre>"},{"location":"reference/lakefs_spec/client_helpers/#lakefs_spec.client_helpers.rev_parse","title":"rev_parse","text":"<pre><code>rev_parse(client: LakeFSClient, repository: str, ref: str | Commit, parent: int = 0) -&gt; Commit\n</code></pre> <p>Resolve a commit reference to the most recent commit or traverses the specified number of parent commits on a branch in a lakeFS repository.</p> PARAMETER  DESCRIPTION <code>client</code> <p>lakeFS client object.</p> <p> TYPE: <code>LakeFSClient</code> </p> <code>repository</code> <p>Name of the repository where the commit will be searched.</p> <p> TYPE: <code>str</code> </p> <code>ref</code> <p>Commit SHA or Commit object (with SHA stored in its <code>id</code> attribute) to resolve.</p> <p> TYPE: <code>str | Commit</code> </p> <code>parent</code> <p>Optionally parse a parent of <code>ref</code> instead of <code>ref</code> itself as indicated by the number. Must be non-negative. <code>parent = 0</code> (the default)  refers to <code>ref</code> itself.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>Commit</code> <p>Commit object representing the resolved commit in the lakeFS repository.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If <code>parent</code> is negative.</li> <li>If the specified number of parent commits exceeds the actual number of available parents.</li> <li>If the provided <code>ref</code> does not match any revision in the specified repository.</li> </ul> Source code in <code>src/lakefs_spec/client_helpers.py</code> <pre><code>def rev_parse(\n    client: LakeFSClient,\n    repository: str,\n    ref: str | Commit,\n    parent: int = 0,\n) -&gt; Commit:\n    \"\"\"\n    Resolve a commit reference to the most recent commit or traverses the specified number of parent commits on a branch in a lakeFS repository.\n\n    Parameters\n    ----------\n    client: LakeFSClient\n        lakeFS client object.\n    repository: str\n        Name of the repository where the commit will be searched.\n    ref: str | Commit\n        Commit SHA or Commit object (with SHA stored in its ``id`` attribute) to resolve.\n    parent: int\n        Optionally parse a parent of ``ref`` instead of ``ref`` itself as indicated by the number.\n        Must be non-negative. ``parent = 0`` (the default)  refers to ``ref`` itself.\n\n    Returns\n    -------\n    Commit\n        Commit object representing the resolved commit in the lakeFS repository.\n\n    Raises\n    ------\n    ValueError\n        - If ``parent`` is negative.\n        - If the specified number of parent commits exceeds the actual number of available parents.\n        - If the provided ``ref`` does not match any revision in the specified repository.\n    \"\"\"\n    if parent &lt; 0:\n        raise ValueError(\"Parent number cannot be negative\")\n    try:\n        if isinstance(ref, Commit):\n            ref = ref.id\n        revisions = list(\n            depaginate(\n                client.refs_api.log_commits, repository, ref, limit=True, amount=2 * (parent + 1)\n            )\n        )\n        if len(revisions) &lt;= parent:\n            raise ValueError(\n                f\"unable to fetch revision {ref}~{parent}: \"\n                f\"ref {ref!r} only has {len(revisions)} parents\"\n            )\n        return revisions[parent]\n    except NotFoundException:\n        raise ValueError(f\"{ref!r} does not match any revision in lakeFS repository {repository!r}\")\n</code></pre>"},{"location":"reference/lakefs_spec/config/","title":"config","text":"<p>Functionality for working with <code>lakectl</code> configuration files useable for authentication in the lakeFS file system.</p>"},{"location":"reference/lakefs_spec/config/#lakefs_spec.config.LakectlConfig","title":"LakectlConfig","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Holds configuration values necessary for authentication with a lakeFS server from Python.</p> Source code in <code>src/lakefs_spec/config.py</code> <pre><code>class LakectlConfig(NamedTuple):\n    \"\"\"\n    Holds configuration values necessary for authentication with a lakeFS server from Python.\n    \"\"\"\n\n    host: str | None = None\n    \"\"\"URL of the lakeFS host, http(s) prefix is optional.\"\"\"\n    username: str | None = None\n    \"\"\"The access key ID to use in authentication with lakeFS.\"\"\"\n    password: str | None = None\n    \"\"\"The secret access key to use in authentication with lakeFS.\"\"\"\n\n    @classmethod\n    def read(cls, path: str | Path) -&gt; \"LakectlConfig\":\n        \"\"\"\n        Read in a lakectl YAML configuration file and parse out relevant authentication parameters.\n\n        Parameters\n        ----------\n        path: str | Path\n            Path to the YAML configuration file.\n\n        Returns\n        -------\n        LakectlConfig\n            The immutable loaded configuration. Missing values are filled with ``None`` placeholders.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the configuration file does not exist.\n        \"\"\"\n        if not Path(path).exists():\n            raise FileNotFoundError(path)\n\n        with open(path, \"r\") as f:\n            obj: dict[str, Any] = yaml.safe_load(f)\n\n        # config struct schema (Golang backend code):\n        # https://github.com/treeverse/lakeFS/blob/master/cmd/lakectl/cmd/root.go\n        creds: dict[str, str] = obj.get(\"credentials\", {})\n        server: dict[str, str] = obj.get(\"server\", {})\n        username = creds.get(\"access_key_id\")\n        password = creds.get(\"secret_access_key\")\n        host = server.get(\"endpoint_url\")\n        return cls(host=host, username=username, password=password)\n</code></pre>"},{"location":"reference/lakefs_spec/config/#lakefs_spec.config.LakectlConfig.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host: str | None = None\n</code></pre> <p>URL of the lakeFS host, http(s) prefix is optional.</p>"},{"location":"reference/lakefs_spec/config/#lakefs_spec.config.LakectlConfig.username","title":"username  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>username: str | None = None\n</code></pre> <p>The access key ID to use in authentication with lakeFS.</p>"},{"location":"reference/lakefs_spec/config/#lakefs_spec.config.LakectlConfig.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password: str | None = None\n</code></pre> <p>The secret access key to use in authentication with lakeFS.</p>"},{"location":"reference/lakefs_spec/config/#lakefs_spec.config.LakectlConfig.read","title":"read  <code>classmethod</code>","text":"<pre><code>read(path: str | Path) -&gt; 'LakectlConfig'\n</code></pre> <p>Read in a lakectl YAML configuration file and parse out relevant authentication parameters.</p> PARAMETER  DESCRIPTION <code>path</code> <p>Path to the YAML configuration file.</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>LakectlConfig</code> <p>The immutable loaded configuration. Missing values are filled with <code>None</code> placeholders.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> Source code in <code>src/lakefs_spec/config.py</code> <pre><code>@classmethod\ndef read(cls, path: str | Path) -&gt; \"LakectlConfig\":\n    \"\"\"\n    Read in a lakectl YAML configuration file and parse out relevant authentication parameters.\n\n    Parameters\n    ----------\n    path: str | Path\n        Path to the YAML configuration file.\n\n    Returns\n    -------\n    LakectlConfig\n        The immutable loaded configuration. Missing values are filled with ``None`` placeholders.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the configuration file does not exist.\n    \"\"\"\n    if not Path(path).exists():\n        raise FileNotFoundError(path)\n\n    with open(path, \"r\") as f:\n        obj: dict[str, Any] = yaml.safe_load(f)\n\n    # config struct schema (Golang backend code):\n    # https://github.com/treeverse/lakeFS/blob/master/cmd/lakectl/cmd/root.go\n    creds: dict[str, str] = obj.get(\"credentials\", {})\n    server: dict[str, str] = obj.get(\"server\", {})\n    username = creds.get(\"access_key_id\")\n    password = creds.get(\"secret_access_key\")\n    host = server.get(\"endpoint_url\")\n    return cls(host=host, username=username, password=password)\n</code></pre>"},{"location":"reference/lakefs_spec/errors/","title":"errors","text":"<p>Error translation facilities to map lakeFS API errors to Python-native OS errors in the lakeFS file system.</p> <p>This is important to honor the fsspec API contract, where users only need to expect builtin Python exceptions to avoid complicated error handling setups.</p>"},{"location":"reference/lakefs_spec/errors/#lakefs_spec.errors.translate_lakefs_error","title":"translate_lakefs_error","text":"<pre><code>translate_lakefs_error(\n    error: ApiException | HTTPError,\n    rpath: str | None = None,\n    message: str | None = None,\n    set_cause: bool = True,\n) -&gt; OSError\n</code></pre> <p>Convert a lakeFS API exception or urllib HTTP error to a Python builtin exception.</p> <p>For some subclasses of <code>lakefs_sdk.ApiException</code>, a direct Python builtin equivalent exists. In these cases, the suitable equivalent is returned. All other classes are converted to a standard <code>IOError</code>.</p> PARAMETER  DESCRIPTION <code>error</code> <p>The exception returned by the lakeFS API.</p> <p> TYPE: <code>ApiException | HTTPError</code> </p> <code>rpath</code> <p>The remote resource path involved in the error.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>message</code> <p>An error message to use for the returned exception.  If not given, the error message returned by the lakeFS server is used instead.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>set_cause</code> <p>Whether to set the <code>__cause__</code> attribute to the previous exception if the exception is translated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>OSError</code> <p>A builtin Python exception ready to be thrown.</p> Source code in <code>src/lakefs_spec/errors.py</code> <pre><code>def translate_lakefs_error(\n    error: ApiException | HTTPError,\n    rpath: str | None = None,\n    message: str | None = None,\n    set_cause: bool = True,\n) -&gt; OSError:\n    \"\"\"\n    Convert a lakeFS API exception or urllib HTTP error to a Python builtin exception.\n\n    For some subclasses of ``lakefs_sdk.ApiException``, a direct Python builtin equivalent exists.\n    In these cases, the suitable equivalent is returned. All other classes are converted to a standard ``IOError``.\n\n    Parameters\n    ----------\n    error: ApiException | HTTPError\n        The exception returned by the lakeFS API.\n    rpath: str | None\n        The remote resource path involved in the error.\n    message: str | None\n        An error message to use for the returned exception.\n         If not given, the error message returned by the lakeFS server is used instead.\n    set_cause: bool\n        Whether to set the ``__cause__`` attribute to the previous exception if the exception is translated.\n\n    Returns\n    -------\n    OSError\n        A builtin Python exception ready to be thrown.\n    \"\"\"\n    if isinstance(error, ApiException):\n        status = error.status\n        reason = json.loads(error.body or \"{}\").get(\"message\", \"\")\n    else:\n        status, reason = error.code, error.reason\n\n    emsg = f\"{status} {reason}\"\n    if rpath:\n        emsg += f\": {rpath!r}\"\n\n    constructor = HTTP_CODE_TO_ERROR.get(status, partial(IOError, errno.EIO))\n    custom_exc = constructor(message or emsg)\n\n    if set_cause:\n        custom_exc.__cause__ = error\n    return custom_exc\n</code></pre>"},{"location":"reference/lakefs_spec/spec/","title":"spec","text":"<p>Core interface definitions for file system interaction with lakeFS from Python, namely the <code>LakeFSFileSystem</code> and <code>LakeFSFile</code> classes.</p>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem","title":"LakeFSFileSystem","text":"<p>             Bases: <code>AbstractFileSystem</code></p> <p>lakeFS file system implementation.</p> <p>Instances of this class are cached based on their constructor arguments.</p> <p>For more information, see the fsspec documentation https://filesystem-spec.readthedocs.io/en/latest/features.html#instance-caching.</p> PARAMETER  DESCRIPTION <code>host</code> <p>The address of your lakeFS instance.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>username</code> <p>The access key name to use in case of access key authentication.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>password</code> <p>The access key secret to use in case of access key authentication.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>api_key</code> <p>The API key to use in case of authentication with an API key.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>api_key_prefix</code> <p>A string prefix to use for the API key in authentication.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>access_token</code> <p>An access token to use in case of access token authentication.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>verify_ssl</code> <p>Whether to verify SSL certificates in API interactions. Do not disable in production.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>ssl_ca_cert</code> <p>A custom certificate PEM file to use to verify the peer in SSL connections.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>proxy</code> <p>Proxy address to use when connecting to a lakeFS server.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>configfile</code> <p><code>lakectl</code> YAML configuration file to read credentials from.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'~/.lakectl.yaml'</code> </p> <code>create_branch_ok</code> <p>Whether to create branches implicitly when not-existing branches are referenced on file uploads.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>source_branch</code> <p>Source branch set as origin when a new branch is implicitly created.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'main'</code> </p> <code>**storage_options</code> <p>Configuration options to pass to the file system's directory cache.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>class LakeFSFileSystem(AbstractFileSystem):\n    \"\"\"\n    lakeFS file system implementation.\n\n    Instances of this class are cached based on their constructor arguments.\n\n    For more information, see the fsspec documentation &lt;https://filesystem-spec.readthedocs.io/en/latest/features.html#instance-caching&gt;.\n\n    Parameters\n    ----------\n    host: str | None\n        The address of your lakeFS instance.\n    username: str | None\n        The access key name to use in case of access key authentication.\n    password: str | None\n        The access key secret to use in case of access key authentication.\n    api_key: str | None\n        The API key to use in case of authentication with an API key.\n    api_key_prefix: str | None\n        A string prefix to use for the API key in authentication.\n    access_token: str | None\n        An access token to use in case of access token authentication.\n    verify_ssl: bool\n        Whether to verify SSL certificates in API interactions. Do not disable in production.\n    ssl_ca_cert: str | None\n        A custom certificate PEM file to use to verify the peer in SSL connections.\n    proxy: str | None\n        Proxy address to use when connecting to a lakeFS server.\n    configfile: str\n        ``lakectl`` YAML configuration file to read credentials from.\n    create_branch_ok: bool\n        Whether to create branches implicitly when not-existing branches are referenced on file uploads.\n    source_branch: str\n        Source branch set as origin when a new branch is implicitly created.\n    **storage_options: Any\n        Configuration options to pass to the file system's directory cache.\n    \"\"\"\n\n    protocol = \"lakefs\"\n\n    def __init__(\n        self,\n        host: str | None = None,\n        username: str | None = None,\n        password: str | None = None,\n        api_key: str | None = None,\n        api_key_prefix: str | None = None,\n        access_token: str | None = None,\n        verify_ssl: bool = True,\n        ssl_ca_cert: str | None = None,\n        proxy: str | None = None,\n        configfile: str = \"~/.lakectl.yaml\",\n        create_branch_ok: bool = True,\n        source_branch: str = \"main\",\n        **storage_options: Any,\n    ):\n        super().__init__(**storage_options)\n\n        if (p := Path(configfile).expanduser()).exists():\n            lakectl_config = LakectlConfig.read(p)\n        else:\n            # empty config.\n            lakectl_config = LakectlConfig()\n\n        configuration = Configuration(\n            host=host or os.getenv(\"LAKEFS_HOST\") or lakectl_config.host,\n            api_key=api_key or os.getenv(\"LAKEFS_API_KEY\"),\n            api_key_prefix=api_key_prefix or os.getenv(\"LAKEFS_API_KEY_PREFIX\"),\n            access_token=access_token or os.getenv(\"LAKEFS_ACCESS_TOKEN\"),\n            username=username or os.getenv(\"LAKEFS_USERNAME\") or lakectl_config.username,\n            password=password or os.getenv(\"LAKEFS_PASSWORD\") or lakectl_config.password,\n            ssl_ca_cert=ssl_ca_cert or os.getenv(\"LAKEFS_SSL_CA_CERT\"),\n        )\n        # proxy address, not part of the constructor\n        configuration.proxy = proxy\n        # whether to verify SSL certs, not part of the constructor\n        configuration.verify_ssl = verify_ssl\n\n        self.client = LakeFSClient(configuration=configuration)\n        self.create_branch_ok = create_branch_ok\n        self.source_branch = source_branch\n\n    @cached_property\n    def _lakefs_server_version(self):\n        with self.wrapped_api_call():\n            version_string = self.client.config_api.get_config().version_config.version\n            return tuple(int(t) for t in version_string.split(\".\"))\n\n    @classmethod\n    @overload\n    def _strip_protocol(cls, path: str | os.PathLike[str] | Path) -&gt; str:\n        ...\n\n    @classmethod\n    @overload\n    def _strip_protocol(cls, path: list[str | os.PathLike[str] | Path]) -&gt; list[str]:\n        ...\n\n    @classmethod\n    def _strip_protocol(cls, path):\n        \"\"\"Copied verbatim from the base class, save for the slash rstrip.\"\"\"\n        if isinstance(path, list):\n            return [cls._strip_protocol(p) for p in path]\n        spath = super()._strip_protocol(path)\n        if stringify_path(path).endswith(\"/\"):\n            return spath + \"/\"\n        return spath\n\n    @property\n    def transaction(self):\n        \"\"\"\n        A context manager within which file uploads and versioning operations are deferred to a\n        queue, and carried out during when exiting the context.\n\n        Requires the file class to implement ``.commit()`` and ``.discard()`` for the normal and exception cases.\n        \"\"\"\n        self._transaction: LakeFSTransaction | None\n        if self._transaction is None:\n            self._transaction = LakeFSTransaction(self)\n        return self._transaction\n\n    def start_transaction(self):\n        \"\"\"\n        Prepare a lakeFS file system transaction without entering the transaction context yet.\n        \"\"\"\n        self._intrans = True\n        self._transaction = LakeFSTransaction(self)\n        return self.transaction\n\n    @contextmanager\n    def wrapped_api_call(\n        self, rpath: str | None = None, message: str | None = None, set_cause: bool = True\n    ) -&gt; Generator[None, None, None]:\n        \"\"\"\n        A context manager to wrap lakeFS API calls, translating any API errors to Python-native OS errors.\n\n        Meant for internal use.\n\n        Parameters\n        ----------\n        rpath: str | None\n            The remote path involved in the requested API call.\n        message: str | None\n            A custom error message to emit instead of parsing the API error response.\n        set_cause: bool\n            Whether to include the original lakeFS API error in the resulting traceback.\n\n        Yields\n        ------\n        None\n            An empty generator, to be used as a context manager.\n\n        Raises\n        ------\n        OSError\n            Translated error from the lakeFS API call, if any.\n        \"\"\"\n        try:\n            yield\n        except ApiException as e:\n            raise translate_lakefs_error(e, rpath=rpath, message=message, set_cause=set_cause)\n\n    def checksum(self, path: str | os.PathLike[str]) -&gt; str | None:\n        \"\"\"\n        Get a remote lakeFS file object's checksum.\n\n        This is usually its MD5 hash, unless another hash function was used on upload.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The remote path to look up the lakeFS checksum for. Must point to a single file object.\n\n        Returns\n        -------\n        str | None\n            The remote file's checksum, or ``None`` if ``path`` points to a directory or does not exist.\n        \"\"\"\n        path = stringify_path(path)\n        try:\n            return self.info(path).get(\"checksum\")\n        except FileNotFoundError:\n            return None\n\n    def exists(self, path: str | os.PathLike[str], **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Check existence of a remote path in a lakeFS repository.\n\n        Input paths can either be files or directories.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The remote path whose existence to check. Must be a fully qualified lakeFS URI.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``LakeFSClient.objects_api.head_object()``.\n\n        Returns\n        -------\n        bool\n            ``True`` if the requested path exists, ``False`` if it does not.\n\n        Raises\n        ------\n        PermissionError\n            If the user does not have sufficient permissions to query object existence.\n        \"\"\"\n        path = stringify_path(path)\n        repository, ref, resource = parse(path)\n\n        try:\n            self.client.objects_api.head_object(repository, ref, resource, **kwargs)\n            return True\n        except NotFoundException:\n            return False\n        except ApiException as e:\n            # in case of an error other than \"not found\", existence cannot be\n            # decided, so raise the translated error.\n            raise translate_lakefs_error(e)\n\n    def cp_file(\n        self, path1: str | os.PathLike[str], path2: str | os.PathLike[str], **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Copy a single file from one remote location to another in lakeFS.\n\n        Parameters\n        ----------\n        path1: str | os.PathLike[str]\n            The remote file location to be copied.\n        path2: str | os.PathLike[str]\n            The (remote) target location to which to copy the file.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``LakeFSClient.objects_api.copy_object()``.\n\n        Raises\n        ------\n        ValueError\n            When attempting to copy objects between repositories.\n        \"\"\"\n        path1 = stringify_path(path1)\n        path2 = stringify_path(path2)\n        if path1 == path2:\n            return\n\n        orig_repo, orig_ref, orig_path = parse(path1)\n        dest_repo, dest_ref, dest_path = parse(path2)\n\n        if orig_repo != dest_repo:\n            raise ValueError(\n                \"can only copy objects within a repository, but got source \"\n                f\"repository {orig_repo!r} and destination repository {dest_repo!r}\"\n            )\n\n        with self.wrapped_api_call():\n            object_copy_creation = ObjectCopyCreation(src_path=orig_path, src_ref=orig_ref)\n            self.client.objects_api.copy_object(\n                repository=dest_repo,\n                branch=dest_ref,\n                dest_path=dest_path,\n                object_copy_creation=object_copy_creation,\n                **kwargs,\n            )\n\n    def get_file(\n        self,\n        rpath: str | os.PathLike[str],\n        lpath: str | os.PathLike[str],\n        callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n        outfile: Any = None,\n        precheck: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Download a single file from a remote lakeFS server to local storage.\n\n        Parameters\n        ----------\n        rpath: str | os.PathLike[str]\n            The remote path to download to local storage. Must be a fully qualified lakeFS URI, and point to a single file.\n        lpath: str | os.PathLike[str]\n            The local path on disk to save the downloaded file to.\n        callback: fsspec.callbacks.Callback\n            An fsspec callback to use during the operation. Can be used to report download progress.\n        outfile: Any\n            A file-like object to save the downloaded content to. Can be used in place of ``lpath``.\n        precheck: bool\n            Check if ``lpath`` already exists and compare its checksum with that of ``rpath``, skipping the download if they match.\n        **kwargs: Any\n            Additional keyword arguments passed to ``AbstractFileSystem.open()``.\n        \"\"\"\n        rpath = stringify_path(rpath)\n        lpath = stringify_path(lpath)\n        lp = Path(lpath)\n        if precheck and lp.exists() and lp.is_file():\n            local_checksum = md5_checksum(lpath, blocksize=self.blocksize)\n            remote_checksum = self.info(rpath).get(\"checksum\")\n            if local_checksum == remote_checksum:\n                logger.info(\n                    f\"Skipping download of resource {rpath!r} to local path {lpath!r}: \"\n                    f\"Resource {lpath!r} exists and checksums match.\"\n                )\n                return\n\n        with self.wrapped_api_call(rpath=rpath):\n            super().get_file(rpath, lpath, callback=callback, outfile=outfile, **kwargs)\n\n    def info(self, path: str | os.PathLike[str], **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"\n        Query a remote lakeFS object's metadata.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The object for which to obtain metadata. Must be a fully qualified lakeFS URI, can either point to a file or a directory.\n        **kwargs: Any\n            Additional keyword arguments to pass to either ``LakeFSClient.objects_api.stat_object()``\n            (if ``path`` points to a file) or ``LakeFSClient.objects_api.list_objects()`` (if ``path`` points to a directory).\n\n        Returns\n        -------\n        dict[str, Any]\n            A dictionary containing metadata on the object, including its full remote path and object type (file or directory).\n\n        Raises\n        ------\n        FileNotFoundError\n            If the ``path`` refers to a non-file path that does not exist in the repository.\n        \"\"\"\n        path = stringify_path(path)\n        repository, ref, resource = parse(path)\n        # first, try with `stat_object` in case of a file.\n        # the condition below checks edge cases of resources that cannot be files.\n        if resource and not resource.endswith(\"/\"):\n            try:\n                # the set of keyword arguments allowed in `list_objects` is a\n                # superset of the keyword arguments for `stat_object`.\n                # Ensure that only admissible keyword arguments are actually\n                # passed to `stat_object`.\n                stat_keywords = [\"presign\", \"user_metadata\"]\n                stat_kwargs = {k: v for k, v in kwargs.items() if k in stat_keywords}\n\n                res = self.client.objects_api.stat_object(\n                    repository=repository, ref=ref, path=resource, **stat_kwargs\n                )\n                return {\n                    \"checksum\": res.checksum,\n                    \"content-type\": res.content_type,\n                    \"mtime\": res.mtime,\n                    \"name\": f\"{repository}/{ref}/{res.path}\",\n                    \"size\": res.size_bytes,\n                    \"type\": \"file\",\n                }\n            except NotFoundException:\n                # fall through, retry with `ls` if it's a directory.\n                pass\n            except ApiException as e:\n                raise translate_lakefs_error(e, rpath=path)\n\n        out = self.ls(path, detail=True, recursive=True, **kwargs)\n        if not out:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), path)\n\n        return {\n            \"name\": path.rstrip(\"/\"),\n            \"size\": sum(o.get(\"size\") or 0 for o in out),\n            \"type\": \"directory\",\n        }\n\n    def ls(\n        self,\n        path: str | os.PathLike[str],\n        detail: bool = True,\n        **kwargs: Any,\n    ) -&gt; list:\n        \"\"\"\n        List all available objects under a given path in lakeFS.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The path under which to list objects. Must be a fully qualified lakeFS URI.\n            Can also point to a file, in which case the file's metadata will be returned.\n        detail: bool\n            Whether to obtain all metadata on the requested objects or just their names.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``LakeFSClient.objects_api.list_objects()``.\n\n            In particular:\n                `refresh: bool`: whether to skip the directory listing cache,\n                `recursive: bool`: whether to list subdirectory contents recursively\n\n        Returns\n        -------\n        list\n            A list of all objects' metadata under the given remote path if ``detail=True``, or alternatively only their names if ``detail=False``.\n        \"\"\"\n\n        def _api_path_type_to_info(path_type: str) -&gt; Literal[\"file\", \"directory\"]:\n            \"\"\"Convert ``list_objects()`` API response field ``path_type`` to ``info.type``.\"\"\"\n            if path_type == \"object\":\n                return \"file\"\n            elif path_type == \"common_prefix\":\n                return \"directory\"\n            else:\n                raise ValueError(f\"unexpected path type {path_type!r}\")\n\n        path = cast(str, stringify_path(path))\n        repository, ref, prefix = parse(path)\n\n        # Try lookup in dircache unless explicitly disabled by `refresh=True` kwarg\n        use_dircache = True\n        if \"refresh\" in kwargs:\n            use_dircache = not kwargs[\"refresh\"]\n            del kwargs[\"refresh\"]  # cannot be forwarded to the API\n\n        if use_dircache:\n            cache_entry: list[Any] | None = None\n            try:\n                cache_entry = self._ls_from_cache(path)\n            except FileNotFoundError:\n                # we patch files missing from an ls call in the cache entry below,\n                # so this should not be an error.\n                pass\n\n            if cache_entry is not None:\n                if not detail:\n                    return [e[\"name\"] for e in cache_entry]\n                return cache_entry[:]\n\n        recursive = kwargs.pop(\"recursive\", False)\n\n        kwargs[\"prefix\"] = prefix\n\n        info = []\n        # stat infos are either the path only (`detail=False`) or a dict full of metadata\n        with self.wrapped_api_call(rpath=path):\n            delimiter = \"\" if recursive else \"/\"\n            objects = depaginate(\n                self.client.objects_api.list_objects,\n                repository,\n                ref,\n                delimiter=delimiter,\n                **kwargs,\n            )\n            for obj in cast(Iterable[ObjectStats], objects):\n                info.append(\n                    {\n                        \"checksum\": obj.checksum,\n                        \"content-type\": obj.content_type,\n                        \"mtime\": obj.mtime,\n                        \"name\": f\"{repository}/{ref}/{obj.path}\",\n                        \"size\": obj.size_bytes,\n                        \"type\": _api_path_type_to_info(obj.path_type),\n                    }\n                )\n\n        # Retry the API call with appended slash if the current result\n        # is just a single directory entry only (not its contents).\n        # This is useful to allow `ls(\"repo/branch/dir\")` calls without\n        # a trailing slash.\n        if len(info) == 1 and info[0][\"type\"] == \"directory\":\n            return self.ls(\n                path + \"/\",\n                detail=detail,\n                **kwargs | {\"refresh\": not use_dircache, \"recursive\": recursive},\n            )\n\n        # cache the info if not empty.\n        if info:\n            # assumes that the returned info is name-sorted.\n            pp = self._parent(info[0][\"name\"])\n            info_copy = info[:]\n            if pp in self.dircache:\n                # ls info has files not in cache, so we update them in the cache entry.\n                cache_entry = self.dircache[pp][:]\n\n                old_names = {e[\"name\"] for e in cache_entry}\n                new_names = {e[\"name\"] for e in info_copy}\n\n                to_remove = old_names - new_names\n                to_update = old_names.intersection(new_names)\n\n                # Remove all entries no longer present in the current listing\n                cache_entry = [e for e in cache_entry if e[\"name\"] not in to_remove]\n\n                # Overwrite existing entries in the cache with its updated values\n                for name in to_update:\n                    old_idx = next(idx for idx, e in enumerate(cache_entry) if e[\"name\"] == name)\n                    new_entry = next(e for e in info_copy if e[\"name\"] == name)\n\n                    cache_entry[old_idx] = new_entry\n                    info_copy.remove(new_entry)\n\n                # Add the remaining (new) entries to the cache\n                cache_entry.extend(info_copy)\n                self.dircache[pp] = sorted(cache_entry, key=operator.itemgetter(\"name\"))\n            else:\n                self.dircache[pp] = info[:]\n\n        if not detail:\n            info = [o[\"name\"] for o in info]\n\n        return info\n\n    def _open(\n        self,\n        path: str,\n        mode: Literal[\"rb\", \"wb\"] = \"rb\",\n        block_size: int | None = None,\n        autocommit: bool = True,\n        cache_options: dict[str, str] | None = None,\n        **kwargs: Any,\n    ) -&gt; LakeFSFile:\n        \"\"\"\n        Dispatch a lakeFS file (local buffer on disk) for the given remote path for up- or downloads depending on ``mode``.\n\n        Internal only, called by ``AbstractFileSystem.open()``.\n\n        Parameters\n        ----------\n        path: str\n            The remote path for which to open a local ``LakeFSFile``. Must be a fully qualified lakeFS URI.\n        mode: Literal[\"rb\", \"wb\"]\n            The file mode indicating its purpose. Use ``rb`` for downloads from lakeFS, ``wb`` for uploads to lakeFS.\n        block_size: int | None\n            The file block size to read at a time. If not set, falls back to fsspec's default blocksize of 5 MB.\n        autocommit: bool\n            Whether to write the file buffer automatically on file closing in write mode.\n        cache_options: dict[str, str] | None\n            Additional caching options to pass to the ``AbstractBufferedFile`` superclass.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``LakeFSClient.objects_api.get_object()`` on download (``mode = 'rb'``),\n            or ``LakeFSClient.objects_api.put_object()`` on upload (``mode='wb'``).\n\n        Returns\n        -------\n        LakeFSFile\n            A local file-like object ready to hold data to be received from / sent to a lakeFS server.\n\n        Raises\n        ------\n        NotImplementedError\n            If ``mode`` is not supported.\n        \"\"\"\n        if mode not in {\"rb\", \"wb\"}:\n            raise NotImplementedError(f\"unsupported mode {mode!r}\")\n\n        return LakeFSFile(\n            self,\n            path=path,\n            mode=mode,\n            block_size=block_size or self.blocksize,\n            autocommit=autocommit,\n            cache_options=cache_options,\n            **kwargs,\n        )\n\n    def put_file_to_blockstore(\n        self,\n        lpath: str | os.PathLike[str],\n        rpath: str | os.PathLike[str],\n        callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n        presign: bool = False,\n        storage_options: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Upload a file to lakeFS by directly putting it into its underlying block storage, thereby reducing the request load\n        on the lakeFS server.\n\n        Requires the corresponding fsspec implementation for the block storage type used by your lakeFS server deployment.\n\n        Supported block storage types are S3 (needs ``s3fs``), GCS (needs ``gcsfs``), and Azure Blob Storage (needs ``adlfs``).\n\n        Note that depending on the block store type, additional configuration like credentials may need to be configured when ``presign=False``.\n\n        Parameters\n        ----------\n        lpath: str | os.PathLike[str]\n            The local path to upload to the lakeFS block storage.\n        rpath: str | os.PathLike[str]\n            The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.\n        callback: fsspec.callbacks.Callback\n            An fsspec callback to use during the operation. Can be used to report download progress.\n        presign: bool\n            Whether to use pre-signed URLs to upload the object via HTTP(S) using ``urllib.request``.\n        storage_options: dict[str, Any] | None\n            Additional file system configuration options to pass to the block storage file system.\n\n        Raises\n        ------\n        ValueError\n            If the blockstore type returned by the lakeFS API is not supported by fsspec.\n        \"\"\"\n        rpath = stringify_path(rpath)\n        lpath = stringify_path(lpath)\n        repository, branch, resource = parse(rpath)\n\n        staging_location = self.client.staging_api.get_physical_address(\n            repository, branch, resource, presign=presign\n        )\n\n        if presign:\n            remote_url = staging_location.presigned_url\n            content_type, _ = mimetypes.guess_type(lpath)\n            if content_type is None:\n                content_type = \"application/octet-stream\"\n            with open(lpath, \"rb\") as f:\n                headers = {\n                    \"Content-Type\": content_type,\n                }\n                request = urllib.request.Request(\n                    url=remote_url, data=f, headers=headers, method=\"PUT\"\n                )\n                try:\n                    if not remote_url.lower().startswith(\"http\"):\n                        raise ValueError(\"Wrong protocol for remote connection\")\n                    else:\n                        logger.debug(f\"Begin upload of {lpath}\")\n                        with urllib.request.urlopen(request):  # nosec [B310:blacklist] # We catch faulty protocols above.\n                            logger.debug(f\"Successfully uploaded {lpath}\")\n                except urllib.error.HTTPError as e:\n                    raise translate_lakefs_error(e, rpath=rpath)\n        else:\n            blockstore_type = self.client.config_api.get_config().storage_config.blockstore_type\n            # lakeFS blockstore name is \"azure\", but Azure's fsspec registry entry is \"az\".\n            if blockstore_type == \"azure\":\n                blockstore_type = \"az\"\n\n            if blockstore_type not in [\"s3\", \"gs\", \"az\"]:\n                raise ValueError(\n                    f\"Blockstore writes are not implemented for blockstore type {blockstore_type!r}\"\n                )\n\n            remote_url = staging_location.physical_address\n            remote = filesystem(blockstore_type, **(storage_options or {}))\n            remote.put_file(lpath, remote_url, callback=callback)\n\n        staging_metadata = StagingMetadata(\n            staging=staging_location,\n            checksum=md5_checksum(lpath, blocksize=self.blocksize),\n            size_bytes=os.path.getsize(lpath),\n        )\n        self.client.staging_api.link_physical_address(\n            repository, branch, resource, staging_metadata\n        )\n\n    def put_file(\n        self,\n        lpath: str | os.PathLike[str],\n        rpath: str | os.PathLike[str],\n        callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n        precheck: bool = True,\n        use_blockstore: bool = False,\n        presign: bool = False,\n        storage_options: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Upload a local file to a remote location on a lakeFS server.\n\n        Note that depending on the block store type, additional configuration like credentials may need to be configured when ``use_blockstore=True`` and ``presign=False``.\n\n        Parameters\n        ----------\n        lpath: str | os.PathLike[str]\n            The local path on disk to upload to the lakeFS server.\n        rpath: str | os.PathLike[str]\n            The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.\n        callback: fsspec.callbacks.Callback\n            An fsspec callback to use during the operation. Can be used to report download progress.\n        precheck: bool\n            Check if ``lpath`` already exists and compare its checksum with that of ``rpath``, skipping the download if they match.\n        use_blockstore: bool\n            Optionally upload the file directly to the underlying block storage, thereby bypassing the lakeFS server and saving a\n            file transfer. Preferable for uploads of large files.\n        presign: bool\n            Whether to use pre-signed URLs to upload the object if ``use_blockstore=True``.\n        storage_options: dict[str, Any] | None\n            Additional file system configuration options to pass to the block storage file system if ``use_blockstore=True``.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``AbstractFileSystem.open()``.\n        \"\"\"\n        lpath = stringify_path(lpath)\n        rpath = stringify_path(rpath)\n        if precheck and Path(lpath).is_file():\n            remote_checksum = self.checksum(rpath)\n            local_checksum = md5_checksum(lpath, blocksize=self.blocksize)\n            if local_checksum == remote_checksum:\n                logger.info(\n                    f\"Skipping upload of resource {lpath!r} to remote path {rpath!r}: \"\n                    f\"Resource {rpath!r} exists and checksums match.\"\n                )\n                return\n\n        if use_blockstore:\n            self.put_file_to_blockstore(\n                lpath,\n                rpath,\n                presign=presign,\n                callback=callback,\n                storage_options=storage_options,\n            )\n        else:\n            with self.wrapped_api_call(rpath=rpath):\n                super().put_file(lpath, rpath, callback=callback, **kwargs)\n\n    def rm_file(self, path: str | os.PathLike[str]) -&gt; None:\n        \"\"\"\n        Stage a remote file for removal on a lakeFS server.\n\n        The file will not actually be removed from the requested branch until a commit is created.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The remote file to delete. Must be a fully qualified lakeFS URI.\n        \"\"\"\n        path = stringify_path(path)\n        repository, branch, resource = parse(path)\n\n        with self.wrapped_api_call(rpath=path):\n            self.client.objects_api.delete_object(\n                repository=repository, branch=branch, path=resource\n            )\n            # Directory listing cache for the containing folder must be invalidated\n            self.dircache.pop(self._parent(path), None)\n\n    def touch(self, path: str | os.PathLike[str], truncate: bool = True, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Create an empty file or update an existing file on a lakeFS server.\n\n        Parameters\n        ----------\n        path: str | os.PathLike[str]\n            The file path to create or update. Must be a fully qualified lakeFS URI.\n        truncate: bool\n            Whether to set the file size to 0 (zero) bytes, even if the path already exists.\n        **kwargs: Any\n            Additional keyword arguments to pass to ``LakeFSFile.open()``.\n\n        Raises\n        ------\n        NotImplementedError\n            If the targeted lakeFS server version does not support `touch()` operations.\n        \"\"\"\n\n        # empty buffer upload errors were fixed in https://github.com/treeverse/lakeFS/issues/7130,\n        # which was first released in lakeFS v1.3.1.\n        if self._lakefs_server_version &lt; (1, 3, 1):\n            version_string = \".\".join(str(v) for v in self._lakefs_server_version)\n            raise NotImplementedError(\n                \"LakeFSFileSystem.touch() is not supported for your lakeFS server version. \"\n                f\"minimum required version: '1.3.1', actual version: {version_string!r}\"\n            )\n\n        super().touch(path=path, truncate=truncate, **kwargs)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.transaction","title":"transaction  <code>property</code>","text":"<pre><code>transaction\n</code></pre> <p>A context manager within which file uploads and versioning operations are deferred to a queue, and carried out during when exiting the context.</p> <p>Requires the file class to implement <code>.commit()</code> and <code>.discard()</code> for the normal and exception cases.</p>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.start_transaction","title":"start_transaction","text":"<pre><code>start_transaction()\n</code></pre> <p>Prepare a lakeFS file system transaction without entering the transaction context yet.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def start_transaction(self):\n    \"\"\"\n    Prepare a lakeFS file system transaction without entering the transaction context yet.\n    \"\"\"\n    self._intrans = True\n    self._transaction = LakeFSTransaction(self)\n    return self.transaction\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.wrapped_api_call","title":"wrapped_api_call","text":"<pre><code>wrapped_api_call(\n    rpath: str | None = None, message: str | None = None, set_cause: bool = True\n) -&gt; Generator[None, None, None]\n</code></pre> <p>A context manager to wrap lakeFS API calls, translating any API errors to Python-native OS errors.</p> <p>Meant for internal use.</p> PARAMETER  DESCRIPTION <code>rpath</code> <p>The remote path involved in the requested API call.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>message</code> <p>A custom error message to emit instead of parsing the API error response.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>set_cause</code> <p>Whether to include the original lakeFS API error in the resulting traceback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> YIELDS DESCRIPTION <code>None</code> <p>An empty generator, to be used as a context manager.</p> RAISES DESCRIPTION <code>OSError</code> <p>Translated error from the lakeFS API call, if any.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>@contextmanager\ndef wrapped_api_call(\n    self, rpath: str | None = None, message: str | None = None, set_cause: bool = True\n) -&gt; Generator[None, None, None]:\n    \"\"\"\n    A context manager to wrap lakeFS API calls, translating any API errors to Python-native OS errors.\n\n    Meant for internal use.\n\n    Parameters\n    ----------\n    rpath: str | None\n        The remote path involved in the requested API call.\n    message: str | None\n        A custom error message to emit instead of parsing the API error response.\n    set_cause: bool\n        Whether to include the original lakeFS API error in the resulting traceback.\n\n    Yields\n    ------\n    None\n        An empty generator, to be used as a context manager.\n\n    Raises\n    ------\n    OSError\n        Translated error from the lakeFS API call, if any.\n    \"\"\"\n    try:\n        yield\n    except ApiException as e:\n        raise translate_lakefs_error(e, rpath=rpath, message=message, set_cause=set_cause)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.checksum","title":"checksum","text":"<pre><code>checksum(path: str | os.PathLike[str]) -&gt; str | None\n</code></pre> <p>Get a remote lakeFS file object's checksum.</p> <p>This is usually its MD5 hash, unless another hash function was used on upload.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The remote path to look up the lakeFS checksum for. Must point to a single file object.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> RETURNS DESCRIPTION <code>str | None</code> <p>The remote file's checksum, or <code>None</code> if <code>path</code> points to a directory or does not exist.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def checksum(self, path: str | os.PathLike[str]) -&gt; str | None:\n    \"\"\"\n    Get a remote lakeFS file object's checksum.\n\n    This is usually its MD5 hash, unless another hash function was used on upload.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The remote path to look up the lakeFS checksum for. Must point to a single file object.\n\n    Returns\n    -------\n    str | None\n        The remote file's checksum, or ``None`` if ``path`` points to a directory or does not exist.\n    \"\"\"\n    path = stringify_path(path)\n    try:\n        return self.info(path).get(\"checksum\")\n    except FileNotFoundError:\n        return None\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.exists","title":"exists","text":"<pre><code>exists(path: str | os.PathLike[str], **kwargs: Any) -&gt; bool\n</code></pre> <p>Check existence of a remote path in a lakeFS repository.</p> <p>Input paths can either be files or directories.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The remote path whose existence to check. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>LakeFSClient.objects_api.head_object()</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the requested path exists, <code>False</code> if it does not.</p> RAISES DESCRIPTION <code>PermissionError</code> <p>If the user does not have sufficient permissions to query object existence.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def exists(self, path: str | os.PathLike[str], **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Check existence of a remote path in a lakeFS repository.\n\n    Input paths can either be files or directories.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The remote path whose existence to check. Must be a fully qualified lakeFS URI.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``LakeFSClient.objects_api.head_object()``.\n\n    Returns\n    -------\n    bool\n        ``True`` if the requested path exists, ``False`` if it does not.\n\n    Raises\n    ------\n    PermissionError\n        If the user does not have sufficient permissions to query object existence.\n    \"\"\"\n    path = stringify_path(path)\n    repository, ref, resource = parse(path)\n\n    try:\n        self.client.objects_api.head_object(repository, ref, resource, **kwargs)\n        return True\n    except NotFoundException:\n        return False\n    except ApiException as e:\n        # in case of an error other than \"not found\", existence cannot be\n        # decided, so raise the translated error.\n        raise translate_lakefs_error(e)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.cp_file","title":"cp_file","text":"<pre><code>cp_file(path1: str | os.PathLike[str], path2: str | os.PathLike[str], **kwargs: Any) -&gt; None\n</code></pre> <p>Copy a single file from one remote location to another in lakeFS.</p> PARAMETER  DESCRIPTION <code>path1</code> <p>The remote file location to be copied.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>path2</code> <p>The (remote) target location to which to copy the file.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>LakeFSClient.objects_api.copy_object()</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When attempting to copy objects between repositories.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def cp_file(\n    self, path1: str | os.PathLike[str], path2: str | os.PathLike[str], **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Copy a single file from one remote location to another in lakeFS.\n\n    Parameters\n    ----------\n    path1: str | os.PathLike[str]\n        The remote file location to be copied.\n    path2: str | os.PathLike[str]\n        The (remote) target location to which to copy the file.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``LakeFSClient.objects_api.copy_object()``.\n\n    Raises\n    ------\n    ValueError\n        When attempting to copy objects between repositories.\n    \"\"\"\n    path1 = stringify_path(path1)\n    path2 = stringify_path(path2)\n    if path1 == path2:\n        return\n\n    orig_repo, orig_ref, orig_path = parse(path1)\n    dest_repo, dest_ref, dest_path = parse(path2)\n\n    if orig_repo != dest_repo:\n        raise ValueError(\n            \"can only copy objects within a repository, but got source \"\n            f\"repository {orig_repo!r} and destination repository {dest_repo!r}\"\n        )\n\n    with self.wrapped_api_call():\n        object_copy_creation = ObjectCopyCreation(src_path=orig_path, src_ref=orig_ref)\n        self.client.objects_api.copy_object(\n            repository=dest_repo,\n            branch=dest_ref,\n            dest_path=dest_path,\n            object_copy_creation=object_copy_creation,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.get_file","title":"get_file","text":"<pre><code>get_file(\n    rpath: str | os.PathLike[str],\n    lpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    outfile: Any = None,\n    precheck: bool = True,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Download a single file from a remote lakeFS server to local storage.</p> PARAMETER  DESCRIPTION <code>rpath</code> <p>The remote path to download to local storage. Must be a fully qualified lakeFS URI, and point to a single file.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>lpath</code> <p>The local path on disk to save the downloaded file to.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>callback</code> <p>An fsspec callback to use during the operation. Can be used to report download progress.</p> <p> TYPE: <code>Callback</code> DEFAULT: <code>_DEFAULT_CALLBACK</code> </p> <code>outfile</code> <p>A file-like object to save the downloaded content to. Can be used in place of <code>lpath</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>precheck</code> <p>Check if <code>lpath</code> already exists and compare its checksum with that of <code>rpath</code>, skipping the download if they match.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>AbstractFileSystem.open()</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def get_file(\n    self,\n    rpath: str | os.PathLike[str],\n    lpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    outfile: Any = None,\n    precheck: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Download a single file from a remote lakeFS server to local storage.\n\n    Parameters\n    ----------\n    rpath: str | os.PathLike[str]\n        The remote path to download to local storage. Must be a fully qualified lakeFS URI, and point to a single file.\n    lpath: str | os.PathLike[str]\n        The local path on disk to save the downloaded file to.\n    callback: fsspec.callbacks.Callback\n        An fsspec callback to use during the operation. Can be used to report download progress.\n    outfile: Any\n        A file-like object to save the downloaded content to. Can be used in place of ``lpath``.\n    precheck: bool\n        Check if ``lpath`` already exists and compare its checksum with that of ``rpath``, skipping the download if they match.\n    **kwargs: Any\n        Additional keyword arguments passed to ``AbstractFileSystem.open()``.\n    \"\"\"\n    rpath = stringify_path(rpath)\n    lpath = stringify_path(lpath)\n    lp = Path(lpath)\n    if precheck and lp.exists() and lp.is_file():\n        local_checksum = md5_checksum(lpath, blocksize=self.blocksize)\n        remote_checksum = self.info(rpath).get(\"checksum\")\n        if local_checksum == remote_checksum:\n            logger.info(\n                f\"Skipping download of resource {rpath!r} to local path {lpath!r}: \"\n                f\"Resource {lpath!r} exists and checksums match.\"\n            )\n            return\n\n    with self.wrapped_api_call(rpath=rpath):\n        super().get_file(rpath, lpath, callback=callback, outfile=outfile, **kwargs)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.info","title":"info","text":"<pre><code>info(path: str | os.PathLike[str], **kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Query a remote lakeFS object's metadata.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The object for which to obtain metadata. Must be a fully qualified lakeFS URI, can either point to a file or a directory.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to either <code>LakeFSClient.objects_api.stat_object()</code> (if <code>path</code> points to a file) or <code>LakeFSClient.objects_api.list_objects()</code> (if <code>path</code> points to a directory).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A dictionary containing metadata on the object, including its full remote path and object type (file or directory).</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the <code>path</code> refers to a non-file path that does not exist in the repository.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def info(self, path: str | os.PathLike[str], **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"\n    Query a remote lakeFS object's metadata.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The object for which to obtain metadata. Must be a fully qualified lakeFS URI, can either point to a file or a directory.\n    **kwargs: Any\n        Additional keyword arguments to pass to either ``LakeFSClient.objects_api.stat_object()``\n        (if ``path`` points to a file) or ``LakeFSClient.objects_api.list_objects()`` (if ``path`` points to a directory).\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary containing metadata on the object, including its full remote path and object type (file or directory).\n\n    Raises\n    ------\n    FileNotFoundError\n        If the ``path`` refers to a non-file path that does not exist in the repository.\n    \"\"\"\n    path = stringify_path(path)\n    repository, ref, resource = parse(path)\n    # first, try with `stat_object` in case of a file.\n    # the condition below checks edge cases of resources that cannot be files.\n    if resource and not resource.endswith(\"/\"):\n        try:\n            # the set of keyword arguments allowed in `list_objects` is a\n            # superset of the keyword arguments for `stat_object`.\n            # Ensure that only admissible keyword arguments are actually\n            # passed to `stat_object`.\n            stat_keywords = [\"presign\", \"user_metadata\"]\n            stat_kwargs = {k: v for k, v in kwargs.items() if k in stat_keywords}\n\n            res = self.client.objects_api.stat_object(\n                repository=repository, ref=ref, path=resource, **stat_kwargs\n            )\n            return {\n                \"checksum\": res.checksum,\n                \"content-type\": res.content_type,\n                \"mtime\": res.mtime,\n                \"name\": f\"{repository}/{ref}/{res.path}\",\n                \"size\": res.size_bytes,\n                \"type\": \"file\",\n            }\n        except NotFoundException:\n            # fall through, retry with `ls` if it's a directory.\n            pass\n        except ApiException as e:\n            raise translate_lakefs_error(e, rpath=path)\n\n    out = self.ls(path, detail=True, recursive=True, **kwargs)\n    if not out:\n        raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), path)\n\n    return {\n        \"name\": path.rstrip(\"/\"),\n        \"size\": sum(o.get(\"size\") or 0 for o in out),\n        \"type\": \"directory\",\n    }\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.ls","title":"ls","text":"<pre><code>ls(path: str | os.PathLike[str], detail: bool = True, **kwargs: Any) -&gt; list\n</code></pre> <p>List all available objects under a given path in lakeFS.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path under which to list objects. Must be a fully qualified lakeFS URI. Can also point to a file, in which case the file's metadata will be returned.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>detail</code> <p>Whether to obtain all metadata on the requested objects or just their names.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>LakeFSClient.objects_api.list_objects()</code>.</p> <p>In particular:     <code>refresh: bool</code>: whether to skip the directory listing cache,     <code>recursive: bool</code>: whether to list subdirectory contents recursively</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>list</code> <p>A list of all objects' metadata under the given remote path if <code>detail=True</code>, or alternatively only their names if <code>detail=False</code>.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def ls(\n    self,\n    path: str | os.PathLike[str],\n    detail: bool = True,\n    **kwargs: Any,\n) -&gt; list:\n    \"\"\"\n    List all available objects under a given path in lakeFS.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The path under which to list objects. Must be a fully qualified lakeFS URI.\n        Can also point to a file, in which case the file's metadata will be returned.\n    detail: bool\n        Whether to obtain all metadata on the requested objects or just their names.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``LakeFSClient.objects_api.list_objects()``.\n\n        In particular:\n            `refresh: bool`: whether to skip the directory listing cache,\n            `recursive: bool`: whether to list subdirectory contents recursively\n\n    Returns\n    -------\n    list\n        A list of all objects' metadata under the given remote path if ``detail=True``, or alternatively only their names if ``detail=False``.\n    \"\"\"\n\n    def _api_path_type_to_info(path_type: str) -&gt; Literal[\"file\", \"directory\"]:\n        \"\"\"Convert ``list_objects()`` API response field ``path_type`` to ``info.type``.\"\"\"\n        if path_type == \"object\":\n            return \"file\"\n        elif path_type == \"common_prefix\":\n            return \"directory\"\n        else:\n            raise ValueError(f\"unexpected path type {path_type!r}\")\n\n    path = cast(str, stringify_path(path))\n    repository, ref, prefix = parse(path)\n\n    # Try lookup in dircache unless explicitly disabled by `refresh=True` kwarg\n    use_dircache = True\n    if \"refresh\" in kwargs:\n        use_dircache = not kwargs[\"refresh\"]\n        del kwargs[\"refresh\"]  # cannot be forwarded to the API\n\n    if use_dircache:\n        cache_entry: list[Any] | None = None\n        try:\n            cache_entry = self._ls_from_cache(path)\n        except FileNotFoundError:\n            # we patch files missing from an ls call in the cache entry below,\n            # so this should not be an error.\n            pass\n\n        if cache_entry is not None:\n            if not detail:\n                return [e[\"name\"] for e in cache_entry]\n            return cache_entry[:]\n\n    recursive = kwargs.pop(\"recursive\", False)\n\n    kwargs[\"prefix\"] = prefix\n\n    info = []\n    # stat infos are either the path only (`detail=False`) or a dict full of metadata\n    with self.wrapped_api_call(rpath=path):\n        delimiter = \"\" if recursive else \"/\"\n        objects = depaginate(\n            self.client.objects_api.list_objects,\n            repository,\n            ref,\n            delimiter=delimiter,\n            **kwargs,\n        )\n        for obj in cast(Iterable[ObjectStats], objects):\n            info.append(\n                {\n                    \"checksum\": obj.checksum,\n                    \"content-type\": obj.content_type,\n                    \"mtime\": obj.mtime,\n                    \"name\": f\"{repository}/{ref}/{obj.path}\",\n                    \"size\": obj.size_bytes,\n                    \"type\": _api_path_type_to_info(obj.path_type),\n                }\n            )\n\n    # Retry the API call with appended slash if the current result\n    # is just a single directory entry only (not its contents).\n    # This is useful to allow `ls(\"repo/branch/dir\")` calls without\n    # a trailing slash.\n    if len(info) == 1 and info[0][\"type\"] == \"directory\":\n        return self.ls(\n            path + \"/\",\n            detail=detail,\n            **kwargs | {\"refresh\": not use_dircache, \"recursive\": recursive},\n        )\n\n    # cache the info if not empty.\n    if info:\n        # assumes that the returned info is name-sorted.\n        pp = self._parent(info[0][\"name\"])\n        info_copy = info[:]\n        if pp in self.dircache:\n            # ls info has files not in cache, so we update them in the cache entry.\n            cache_entry = self.dircache[pp][:]\n\n            old_names = {e[\"name\"] for e in cache_entry}\n            new_names = {e[\"name\"] for e in info_copy}\n\n            to_remove = old_names - new_names\n            to_update = old_names.intersection(new_names)\n\n            # Remove all entries no longer present in the current listing\n            cache_entry = [e for e in cache_entry if e[\"name\"] not in to_remove]\n\n            # Overwrite existing entries in the cache with its updated values\n            for name in to_update:\n                old_idx = next(idx for idx, e in enumerate(cache_entry) if e[\"name\"] == name)\n                new_entry = next(e for e in info_copy if e[\"name\"] == name)\n\n                cache_entry[old_idx] = new_entry\n                info_copy.remove(new_entry)\n\n            # Add the remaining (new) entries to the cache\n            cache_entry.extend(info_copy)\n            self.dircache[pp] = sorted(cache_entry, key=operator.itemgetter(\"name\"))\n        else:\n            self.dircache[pp] = info[:]\n\n    if not detail:\n        info = [o[\"name\"] for o in info]\n\n    return info\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.put_file_to_blockstore","title":"put_file_to_blockstore","text":"<pre><code>put_file_to_blockstore(\n    lpath: str | os.PathLike[str],\n    rpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    presign: bool = False,\n    storage_options: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Upload a file to lakeFS by directly putting it into its underlying block storage, thereby reducing the request load on the lakeFS server.</p> <p>Requires the corresponding fsspec implementation for the block storage type used by your lakeFS server deployment.</p> <p>Supported block storage types are S3 (needs <code>s3fs</code>), GCS (needs <code>gcsfs</code>), and Azure Blob Storage (needs <code>adlfs</code>).</p> <p>Note that depending on the block store type, additional configuration like credentials may need to be configured when <code>presign=False</code>.</p> PARAMETER  DESCRIPTION <code>lpath</code> <p>The local path to upload to the lakeFS block storage.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>rpath</code> <p>The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>callback</code> <p>An fsspec callback to use during the operation. Can be used to report download progress.</p> <p> TYPE: <code>Callback</code> DEFAULT: <code>_DEFAULT_CALLBACK</code> </p> <code>presign</code> <p>Whether to use pre-signed URLs to upload the object via HTTP(S) using <code>urllib.request</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>storage_options</code> <p>Additional file system configuration options to pass to the block storage file system.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the blockstore type returned by the lakeFS API is not supported by fsspec.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def put_file_to_blockstore(\n    self,\n    lpath: str | os.PathLike[str],\n    rpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    presign: bool = False,\n    storage_options: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Upload a file to lakeFS by directly putting it into its underlying block storage, thereby reducing the request load\n    on the lakeFS server.\n\n    Requires the corresponding fsspec implementation for the block storage type used by your lakeFS server deployment.\n\n    Supported block storage types are S3 (needs ``s3fs``), GCS (needs ``gcsfs``), and Azure Blob Storage (needs ``adlfs``).\n\n    Note that depending on the block store type, additional configuration like credentials may need to be configured when ``presign=False``.\n\n    Parameters\n    ----------\n    lpath: str | os.PathLike[str]\n        The local path to upload to the lakeFS block storage.\n    rpath: str | os.PathLike[str]\n        The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.\n    callback: fsspec.callbacks.Callback\n        An fsspec callback to use during the operation. Can be used to report download progress.\n    presign: bool\n        Whether to use pre-signed URLs to upload the object via HTTP(S) using ``urllib.request``.\n    storage_options: dict[str, Any] | None\n        Additional file system configuration options to pass to the block storage file system.\n\n    Raises\n    ------\n    ValueError\n        If the blockstore type returned by the lakeFS API is not supported by fsspec.\n    \"\"\"\n    rpath = stringify_path(rpath)\n    lpath = stringify_path(lpath)\n    repository, branch, resource = parse(rpath)\n\n    staging_location = self.client.staging_api.get_physical_address(\n        repository, branch, resource, presign=presign\n    )\n\n    if presign:\n        remote_url = staging_location.presigned_url\n        content_type, _ = mimetypes.guess_type(lpath)\n        if content_type is None:\n            content_type = \"application/octet-stream\"\n        with open(lpath, \"rb\") as f:\n            headers = {\n                \"Content-Type\": content_type,\n            }\n            request = urllib.request.Request(\n                url=remote_url, data=f, headers=headers, method=\"PUT\"\n            )\n            try:\n                if not remote_url.lower().startswith(\"http\"):\n                    raise ValueError(\"Wrong protocol for remote connection\")\n                else:\n                    logger.debug(f\"Begin upload of {lpath}\")\n                    with urllib.request.urlopen(request):  # nosec [B310:blacklist] # We catch faulty protocols above.\n                        logger.debug(f\"Successfully uploaded {lpath}\")\n            except urllib.error.HTTPError as e:\n                raise translate_lakefs_error(e, rpath=rpath)\n    else:\n        blockstore_type = self.client.config_api.get_config().storage_config.blockstore_type\n        # lakeFS blockstore name is \"azure\", but Azure's fsspec registry entry is \"az\".\n        if blockstore_type == \"azure\":\n            blockstore_type = \"az\"\n\n        if blockstore_type not in [\"s3\", \"gs\", \"az\"]:\n            raise ValueError(\n                f\"Blockstore writes are not implemented for blockstore type {blockstore_type!r}\"\n            )\n\n        remote_url = staging_location.physical_address\n        remote = filesystem(blockstore_type, **(storage_options or {}))\n        remote.put_file(lpath, remote_url, callback=callback)\n\n    staging_metadata = StagingMetadata(\n        staging=staging_location,\n        checksum=md5_checksum(lpath, blocksize=self.blocksize),\n        size_bytes=os.path.getsize(lpath),\n    )\n    self.client.staging_api.link_physical_address(\n        repository, branch, resource, staging_metadata\n    )\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.put_file","title":"put_file","text":"<pre><code>put_file(\n    lpath: str | os.PathLike[str],\n    rpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    precheck: bool = True,\n    use_blockstore: bool = False,\n    presign: bool = False,\n    storage_options: dict[str, Any] | None = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Upload a local file to a remote location on a lakeFS server.</p> <p>Note that depending on the block store type, additional configuration like credentials may need to be configured when <code>use_blockstore=True</code> and <code>presign=False</code>.</p> PARAMETER  DESCRIPTION <code>lpath</code> <p>The local path on disk to upload to the lakeFS server.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>rpath</code> <p>The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>callback</code> <p>An fsspec callback to use during the operation. Can be used to report download progress.</p> <p> TYPE: <code>Callback</code> DEFAULT: <code>_DEFAULT_CALLBACK</code> </p> <code>precheck</code> <p>Check if <code>lpath</code> already exists and compare its checksum with that of <code>rpath</code>, skipping the download if they match.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>use_blockstore</code> <p>Optionally upload the file directly to the underlying block storage, thereby bypassing the lakeFS server and saving a file transfer. Preferable for uploads of large files.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>presign</code> <p>Whether to use pre-signed URLs to upload the object if <code>use_blockstore=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>storage_options</code> <p>Additional file system configuration options to pass to the block storage file system if <code>use_blockstore=True</code>.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>AbstractFileSystem.open()</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def put_file(\n    self,\n    lpath: str | os.PathLike[str],\n    rpath: str | os.PathLike[str],\n    callback: fsspec.callbacks.Callback = _DEFAULT_CALLBACK,\n    precheck: bool = True,\n    use_blockstore: bool = False,\n    presign: bool = False,\n    storage_options: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Upload a local file to a remote location on a lakeFS server.\n\n    Note that depending on the block store type, additional configuration like credentials may need to be configured when ``use_blockstore=True`` and ``presign=False``.\n\n    Parameters\n    ----------\n    lpath: str | os.PathLike[str]\n        The local path on disk to upload to the lakeFS server.\n    rpath: str | os.PathLike[str]\n        The remote target path to upload the local file to. Must be a fully qualified lakeFS URI.\n    callback: fsspec.callbacks.Callback\n        An fsspec callback to use during the operation. Can be used to report download progress.\n    precheck: bool\n        Check if ``lpath`` already exists and compare its checksum with that of ``rpath``, skipping the download if they match.\n    use_blockstore: bool\n        Optionally upload the file directly to the underlying block storage, thereby bypassing the lakeFS server and saving a\n        file transfer. Preferable for uploads of large files.\n    presign: bool\n        Whether to use pre-signed URLs to upload the object if ``use_blockstore=True``.\n    storage_options: dict[str, Any] | None\n        Additional file system configuration options to pass to the block storage file system if ``use_blockstore=True``.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``AbstractFileSystem.open()``.\n    \"\"\"\n    lpath = stringify_path(lpath)\n    rpath = stringify_path(rpath)\n    if precheck and Path(lpath).is_file():\n        remote_checksum = self.checksum(rpath)\n        local_checksum = md5_checksum(lpath, blocksize=self.blocksize)\n        if local_checksum == remote_checksum:\n            logger.info(\n                f\"Skipping upload of resource {lpath!r} to remote path {rpath!r}: \"\n                f\"Resource {rpath!r} exists and checksums match.\"\n            )\n            return\n\n    if use_blockstore:\n        self.put_file_to_blockstore(\n            lpath,\n            rpath,\n            presign=presign,\n            callback=callback,\n            storage_options=storage_options,\n        )\n    else:\n        with self.wrapped_api_call(rpath=rpath):\n            super().put_file(lpath, rpath, callback=callback, **kwargs)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.rm_file","title":"rm_file","text":"<pre><code>rm_file(path: str | os.PathLike[str]) -&gt; None\n</code></pre> <p>Stage a remote file for removal on a lakeFS server.</p> <p>The file will not actually be removed from the requested branch until a commit is created.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The remote file to delete. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def rm_file(self, path: str | os.PathLike[str]) -&gt; None:\n    \"\"\"\n    Stage a remote file for removal on a lakeFS server.\n\n    The file will not actually be removed from the requested branch until a commit is created.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The remote file to delete. Must be a fully qualified lakeFS URI.\n    \"\"\"\n    path = stringify_path(path)\n    repository, branch, resource = parse(path)\n\n    with self.wrapped_api_call(rpath=path):\n        self.client.objects_api.delete_object(\n            repository=repository, branch=branch, path=resource\n        )\n        # Directory listing cache for the containing folder must be invalidated\n        self.dircache.pop(self._parent(path), None)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFileSystem.touch","title":"touch","text":"<pre><code>touch(path: str | os.PathLike[str], truncate: bool = True, **kwargs: Any) -&gt; None\n</code></pre> <p>Create an empty file or update an existing file on a lakeFS server.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The file path to create or update. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>truncate</code> <p>Whether to set the file size to 0 (zero) bytes, even if the path already exists.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>LakeFSFile.open()</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the targeted lakeFS server version does not support <code>touch()</code> operations.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def touch(self, path: str | os.PathLike[str], truncate: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Create an empty file or update an existing file on a lakeFS server.\n\n    Parameters\n    ----------\n    path: str | os.PathLike[str]\n        The file path to create or update. Must be a fully qualified lakeFS URI.\n    truncate: bool\n        Whether to set the file size to 0 (zero) bytes, even if the path already exists.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``LakeFSFile.open()``.\n\n    Raises\n    ------\n    NotImplementedError\n        If the targeted lakeFS server version does not support `touch()` operations.\n    \"\"\"\n\n    # empty buffer upload errors were fixed in https://github.com/treeverse/lakeFS/issues/7130,\n    # which was first released in lakeFS v1.3.1.\n    if self._lakefs_server_version &lt; (1, 3, 1):\n        version_string = \".\".join(str(v) for v in self._lakefs_server_version)\n        raise NotImplementedError(\n            \"LakeFSFileSystem.touch() is not supported for your lakeFS server version. \"\n            f\"minimum required version: '1.3.1', actual version: {version_string!r}\"\n        )\n\n    super().touch(path=path, truncate=truncate, **kwargs)\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFile","title":"LakeFSFile","text":"<p>             Bases: <code>AbstractBufferedFile</code></p> <p>lakeFS file implementation.</p>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFile--notes","title":"Notes","text":"<p>Creates a local buffer on disk for the given remote path for up- or downloads depending on <code>mode</code>.</p> <p>Read operations are buffered, write operations are unbuffered. This means that local files to be uploaded will be loaded entirely into memory.</p> PARAMETER  DESCRIPTION <code>fs</code> <p>The lakeFS file system associated to this file.</p> <p> TYPE: <code>LakeFSFileSystem</code> </p> <code>path</code> <p>The remote path to either up- or download depending on <code>mode</code>. Must be a fully qualified lakeFS URI.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>mode</code> <p>The file mode indicating its purpose. Use <code>rb</code> for downloads from lakeFS, <code>wb</code> for uploads to lakeFS.</p> <p> TYPE: <code>Literal['rb', 'wb']</code> DEFAULT: <code>'rb'</code> </p> <code>block_size</code> <p>The file block size to read at a time. If not set, falls back to fsspec's default blocksize of 5 MB.</p> <p> TYPE: <code>int | str</code> DEFAULT: <code>'default'</code> </p> <code>autocommit</code> <p>Whether to write the file buffer automatically to lakeFS on file closing in write mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cache_type</code> <p>Cache policy in read mode (any of <code>readahead</code>, <code>none</code>, <code>mmap</code>, <code>bytes</code>). See <code>AbstractBufferedFile</code> for details.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'readahead'</code> </p> <code>cache_options</code> <p>Additional options passed to the constructor for the cache specified by <code>cache_type</code>.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>size</code> <p>If given and <code>mode='rb'</code>, this will be used as the file size (in bytes) instead of determining it from the remote file.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>LakeFSClient.objects_api.get_object()</code> on download (<code>mode='rb'</code>), or <code>LakeFSClient.objects_api.put_object()</code> on upload (<code>mode='wb'</code>).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>class LakeFSFile(AbstractBufferedFile):\n    \"\"\"\n    lakeFS file implementation.\n\n    Notes\n    -----\n    Creates a local buffer on disk for the given remote path for up- or downloads depending on ``mode``.\n\n    Read operations are buffered, write operations are unbuffered. This means that local files to be uploaded will be loaded entirely into memory.\n\n    Parameters\n    ----------\n    fs: LakeFSFileSystem\n        The lakeFS file system associated to this file.\n    path: str | os.PathLike[str]\n        The remote path to either up- or download depending on ``mode``. Must be a fully qualified lakeFS URI.\n    mode: Literal[\"rb\", \"wb\"]\n        The file mode indicating its purpose. Use ``rb`` for downloads from lakeFS, ``wb`` for uploads to lakeFS.\n    block_size: int | str\n        The file block size to read at a time. If not set, falls back to fsspec's default blocksize of 5 MB.\n    autocommit: bool\n        Whether to write the file buffer automatically to lakeFS on file closing in write mode.\n    cache_type: str\n        Cache policy in read mode (any of ``readahead``, ``none``, ``mmap``, ``bytes``). See ``AbstractBufferedFile`` for details.\n    cache_options: dict[str, Any] | None\n        Additional options passed to the constructor for the cache specified by ``cache_type``.\n    size: int | None\n        If given and ``mode='rb'``, this will be used as the file size (in bytes) instead of determining it from the remote file.\n    **kwargs: Any\n        Additional keyword arguments to pass to ``LakeFSClient.objects_api.get_object()`` on download (``mode='rb'``),\n        or ``LakeFSClient.objects_api.put_object()`` on upload (``mode='wb'``).\n    \"\"\"\n\n    def __init__(\n        self,\n        fs: LakeFSFileSystem,\n        path: str | os.PathLike[str],\n        mode: Literal[\"rb\", \"wb\"] = \"rb\",\n        block_size: int | str = \"default\",\n        autocommit: bool = True,\n        cache_type: str = \"readahead\",\n        cache_options: dict[str, Any] | None = None,\n        size: int | None = None,\n        **kwargs: Any,\n    ):\n        path = stringify_path(path)\n        super().__init__(\n            fs,\n            path,\n            mode=mode,\n            block_size=block_size,\n            autocommit=autocommit,\n            cache_type=cache_type,\n            cache_options=cache_options,\n            size=size,\n            **kwargs,\n        )\n\n        self.buffer: io.BytesIO\n        if mode == \"wb\" and self.fs.create_branch_ok:\n            repository, branch, resource = parse(path)\n            create_branch(self.fs.client, repository, branch, self.fs.source_branch)\n\n    def _upload_chunk(self, final: bool = False) -&gt; bool:\n        \"\"\"\n        Commit the file on final chunk via single-shot upload, no-op otherwise.\n\n        Parameters\n        ----------\n        final: bool\n            Proceed with uploading the file if ``self.autocommit=True``.\n\n        Returns\n        -------\n        bool\n            If the file buffer needs more data to be written before initiating the upload.\n        \"\"\"\n        if final and self.autocommit:\n            self.commit()\n        return not final\n\n    def commit(self):\n        \"\"\"\n        Upload the file to lakeFS in single-shot mode.\n\n        Results in an unbuffered upload, and a memory allocation in the magnitude of the file size on the caller's host machine.\n        \"\"\"\n        repository, branch, resource = parse(self.path)\n\n        with self.fs.wrapped_api_call(rpath=self.path):\n            # empty buffer is equivalent to a touch()\n            self.buffer.seek(0)\n            self.fs.client.objects_api.upload_object(\n                repository=repository,\n                branch=branch,\n                path=resource,\n                content=self.buffer.read(),\n                **self.kwargs,\n            )\n\n        self.buffer = io.BytesIO()\n\n    def discard(self):\n        \"\"\"Discard the file's current buffer.\"\"\"\n        self.buffer = io.BytesIO()  # discards the data, but in a type-safe way.\n\n    def flush(self, force: bool = False) -&gt; None:\n        \"\"\"\n        Write buffered data to backend store.\n\n        Writes the current buffer, if it is larger than the block-size, or if\n        the file is being closed.\n\n        In contrast to the abstract class, this implementation does NOT unload the buffer\n        if it is larger than the block size, because the lakeFS server does not support\n        multipart uploads.\n\n        Parameters\n        ----------\n        force: bool\n            When closing, write the last block even if it is smaller than\n            blocks are allowed to be. Disallows further writing to this file.\n\n        Raises\n        ------\n        ValueError\n            If the file is closed, or has already been forcibly flushed and ``force=True``.\n        \"\"\"\n\n        if self.closed:\n            raise ValueError(\"Flush on closed file\")\n        self.forced: bool\n        if force and self.forced:\n            raise ValueError(\"Force flush cannot be called more than once\")\n        if force:\n            self.forced = True\n\n        if self.mode != \"wb\":\n            # no-op to flush on read-mode\n            return\n\n        if not force and self.buffer.tell() &lt; self.blocksize:\n            # Defer write on small block\n            return\n\n        self.offset: int\n        if self.offset is None:\n            # Initialize an upload\n            self.offset = 0\n\n        if self._upload_chunk(final=force) is not False:\n            self.offset += self.buffer.seek(0, 2)\n\n    def _fetch_range(self, start: int, end: int) -&gt; bytes:\n        \"\"\"\n        Fetch a byte range of the ``LakeFSFile``'s target remote path.\n\n        The byte range is right-exclusive, meaning that the amount of transferred bytes equals ``end - start``.\n\n        Parameters\n        ----------\n        start: int\n            Start of the byte range, inclusive.\n        end: int\n            End of the byte range, exclusive. Must be greater than ``start``.\n\n        Returns\n        -------\n        bytes\n            A byte array holding the downloaded data from lakeFS.\n        \"\"\"\n        repository, ref, resource = parse(self.path)\n        with self.fs.wrapped_api_call(rpath=self.path):\n            return self.fs.client.objects_api.get_object(\n                repository, ref, resource, range=f\"bytes={start}-{end - 1}\", **self.kwargs\n            )\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFile.commit","title":"commit","text":"<pre><code>commit()\n</code></pre> <p>Upload the file to lakeFS in single-shot mode.</p> <p>Results in an unbuffered upload, and a memory allocation in the magnitude of the file size on the caller's host machine.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def commit(self):\n    \"\"\"\n    Upload the file to lakeFS in single-shot mode.\n\n    Results in an unbuffered upload, and a memory allocation in the magnitude of the file size on the caller's host machine.\n    \"\"\"\n    repository, branch, resource = parse(self.path)\n\n    with self.fs.wrapped_api_call(rpath=self.path):\n        # empty buffer is equivalent to a touch()\n        self.buffer.seek(0)\n        self.fs.client.objects_api.upload_object(\n            repository=repository,\n            branch=branch,\n            path=resource,\n            content=self.buffer.read(),\n            **self.kwargs,\n        )\n\n    self.buffer = io.BytesIO()\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFile.discard","title":"discard","text":"<pre><code>discard()\n</code></pre> <p>Discard the file's current buffer.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def discard(self):\n    \"\"\"Discard the file's current buffer.\"\"\"\n    self.buffer = io.BytesIO()  # discards the data, but in a type-safe way.\n</code></pre>"},{"location":"reference/lakefs_spec/spec/#lakefs_spec.spec.LakeFSFile.flush","title":"flush","text":"<pre><code>flush(force: bool = False) -&gt; None\n</code></pre> <p>Write buffered data to backend store.</p> <p>Writes the current buffer, if it is larger than the block-size, or if the file is being closed.</p> <p>In contrast to the abstract class, this implementation does NOT unload the buffer if it is larger than the block size, because the lakeFS server does not support multipart uploads.</p> PARAMETER  DESCRIPTION <code>force</code> <p>When closing, write the last block even if it is smaller than blocks are allowed to be. Disallows further writing to this file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the file is closed, or has already been forcibly flushed and <code>force=True</code>.</p> Source code in <code>src/lakefs_spec/spec.py</code> <pre><code>def flush(self, force: bool = False) -&gt; None:\n    \"\"\"\n    Write buffered data to backend store.\n\n    Writes the current buffer, if it is larger than the block-size, or if\n    the file is being closed.\n\n    In contrast to the abstract class, this implementation does NOT unload the buffer\n    if it is larger than the block size, because the lakeFS server does not support\n    multipart uploads.\n\n    Parameters\n    ----------\n    force: bool\n        When closing, write the last block even if it is smaller than\n        blocks are allowed to be. Disallows further writing to this file.\n\n    Raises\n    ------\n    ValueError\n        If the file is closed, or has already been forcibly flushed and ``force=True``.\n    \"\"\"\n\n    if self.closed:\n        raise ValueError(\"Flush on closed file\")\n    self.forced: bool\n    if force and self.forced:\n        raise ValueError(\"Force flush cannot be called more than once\")\n    if force:\n        self.forced = True\n\n    if self.mode != \"wb\":\n        # no-op to flush on read-mode\n        return\n\n    if not force and self.buffer.tell() &lt; self.blocksize:\n        # Defer write on small block\n        return\n\n    self.offset: int\n    if self.offset is None:\n        # Initialize an upload\n        self.offset = 0\n\n    if self._upload_chunk(final=force) is not False:\n        self.offset += self.buffer.seek(0, 2)\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/","title":"transaction","text":"<p>Functionality for extended lakeFS transactions to conduct versioning operations between file uploads.</p>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.Placeholder","title":"Placeholder  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A generic placeholder for a value computed by the lakeFS server in a versioning operation during a transaction.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>@dataclass\nclass Placeholder(Generic[T]):\n    \"\"\"A generic placeholder for a value computed by the lakeFS server in a versioning operation during a transaction.\"\"\"\n\n    value: T | None = None\n    \"\"\"The abstract value. Set only on completion of the versioning operation during the defining transaction.\"\"\"\n\n    def available(self):\n        \"\"\"Whether the wrapped value is available, i.e. already computed.\"\"\"\n        return self.value is not None\n\n    def set_value(self, value: T) -&gt; None:\n        \"\"\"Fill in the placeholder. Not meant to be called directly except in the completion of the transaction.\"\"\"\n        self.value = value\n\n    def unwrap(self) -&gt; T:\n        \"\"\"Return the placeholder's value after it has been filled.\"\"\"\n        if self.value is None:\n            raise RuntimeError(\"placeholder unfilled\")\n        return self.value\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.Placeholder.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: T | None = None\n</code></pre> <p>The abstract value. Set only on completion of the versioning operation during the defining transaction.</p>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.Placeholder.available","title":"available","text":"<pre><code>available()\n</code></pre> <p>Whether the wrapped value is available, i.e. already computed.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def available(self):\n    \"\"\"Whether the wrapped value is available, i.e. already computed.\"\"\"\n    return self.value is not None\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.Placeholder.set_value","title":"set_value","text":"<pre><code>set_value(value: T) -&gt; None\n</code></pre> <p>Fill in the placeholder. Not meant to be called directly except in the completion of the transaction.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def set_value(self, value: T) -&gt; None:\n    \"\"\"Fill in the placeholder. Not meant to be called directly except in the completion of the transaction.\"\"\"\n    self.value = value\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.Placeholder.unwrap","title":"unwrap","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Return the placeholder's value after it has been filled.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def unwrap(self) -&gt; T:\n    \"\"\"Return the placeholder's value after it has been filled.\"\"\"\n    if self.value is None:\n        raise RuntimeError(\"placeholder unfilled\")\n    return self.value\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction","title":"LakeFSTransaction","text":"<p>             Bases: <code>Transaction</code></p> <p>A lakeFS transaction model capable of versioning operations in between file uploads.</p> PARAMETER  DESCRIPTION <code>fs</code> <p>The lakeFS file system associated with the transaction.</p> <p> TYPE: <code>'LakeFSFileSystem'</code> </p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>class LakeFSTransaction(Transaction):\n    \"\"\"\n    A lakeFS transaction model capable of versioning operations in between file uploads.\n\n    Parameters\n    ----------\n    fs: LakeFSFileSystem\n        The lakeFS file system associated with the transaction.\n    \"\"\"\n\n    def __init__(self, fs: \"LakeFSFileSystem\"):\n        super().__init__(fs=fs)\n        self.fs: \"LakeFSFileSystem\"\n        self.files: deque[AbstractBufferedFile | VersioningOpTuple] = deque(self.files)\n\n    def __enter__(self):\n        self.fs._intrans = True\n        return self\n\n    def commit(\n        self, repository: str, branch: str, message: str, metadata: dict[str, str] | None = None\n    ) -&gt; Placeholder[Commit]:\n        \"\"\"\n        Create a commit on a branch in a repository with a commit message and attached metadata.\n\n        Parameters\n        ----------\n        repository: str\n            The repository to create the commit in.\n        branch: str\n            The name of the branch to commit on.\n        message: str\n            The commit message to attach to the newly created commit.\n        metadata: dict[str, str] | None\n            Optional metadata to enrich the created commit with (author, e-mail, etc.).\n\n        Returns\n        -------\n        Placeholder[Commit]\n            A placeholder for the commit created by the dispatched ``commit`` API call.\n        \"\"\"\n        # bind all arguments to the client helper function, and then add it to the file-/callstack.\n        op = partial(\n            commit, repository=repository, branch=branch, message=message, metadata=metadata\n        )\n        p: Placeholder[Commit] = Placeholder()\n        self.files.append((op, p))\n        # return a placeholder for the commit.\n        return p\n\n    def complete(self, commit: bool = True) -&gt; None:\n        \"\"\"\n        Finish the transaction by unwinding the file/versioning op stack via\n\n        1. Committing or discarding in case of a file, and\n        2. Conducting versioning operations using the file system's client.\n\n        No operations happen and all files are discarded if ``commit == False``,\n        which is the case, e.g., if an exception happens in the context manager.\n\n        Parameters\n        ----------\n        commit: bool\n            Whether to conduct operations queued in the transaction.\n        \"\"\"\n        while self.files:\n            # fsspec base class calls `append` on the file, which means we\n            # have to pop from the left to preserve order.\n            f = self.files.popleft()\n            if isinstance(f, AbstractBufferedFile):\n                if commit:\n                    f.commit()\n                else:\n                    f.discard()\n            else:\n                # client helper + return value case.\n                op, retval = f\n                if commit:\n                    result = op(self.fs.client)\n                    # if the transaction member returns a placeholder,\n                    # fill it with the result of the client helper.\n                    if isinstance(retval, Placeholder):\n                        retval.set_value(result)\n\n        self.fs._intrans = False\n\n    def create_branch(\n        self, repository: str, name: str, source_branch: str, exist_ok: bool = True\n    ) -&gt; str:\n        \"\"\"\n        Create a branch ``name`` in a repository, branching off ``source_branch``.\n\n        Parameters\n        ----------\n        repository: str\n            Repository name.\n        name: str\n            Name of the branch to be created.\n        source_branch: str\n            Name of the source branch that the new branch is created from.\n        exist_ok: bool\n            Ignore creation errors if the branch already exists.\n\n        Returns\n        -------\n        str\n            The requested branch name.\n        \"\"\"\n        op = partial(\n            create_branch,\n            repository=repository,\n            name=name,\n            source_branch=source_branch,\n            exist_ok=exist_ok,\n        )\n        self.files.append((op, name))\n        return name\n\n    def merge(self, repository: str, source_ref: str, into: str) -&gt; None:\n        \"\"\"\n        Merge a branch into another branch in a repository.\n\n        Parameters\n        ----------\n        repository: str\n            Name of the repository.\n        source_ref: str\n            Source reference containing the changes to merge. Can be a branch name or partial commit SHA.\n        into: str\n            Target branch into which the changes will be merged.\n        \"\"\"\n        op = partial(merge, repository=repository, source_ref=source_ref, target_branch=into)\n        self.files.append((op, None))\n        return None\n\n    def revert(self, repository: str, branch: str, parent_number: int = 1) -&gt; None:\n        \"\"\"\n        Revert a previous commit on a branch.\n\n        Parameters\n        ----------\n        repository: str\n            Name of the repository.\n        branch: str\n            Branch on which the commit should be reverted.\n        parent_number: int\n            If there are multiple parents to a commit, specify to which parent the commit should be reverted.\n            ``parent_number = 1`` (the default)  refers to the first parent commit of the current ``branch`` tip.\n        \"\"\"\n\n        op = partial(revert, repository=repository, branch=branch, parent_number=parent_number)\n        self.files.append((op, None))\n        return None\n\n    def rev_parse(\n        self, repository: str, ref: str | Placeholder[Commit], parent: int = 0\n    ) -&gt; Placeholder[Commit]:\n        \"\"\"\n        Parse a given reference or any of its parents in a repository.\n\n        Parameters\n        ----------\n        repository: str\n            Name of the repository.\n        ref: str | Placeholder[Commit]\n            Commit SHA or commit placeholder object to resolve.\n        parent: int\n            Optionally parse a parent of ``ref`` instead of ``ref`` itself as indicated by the number.\n            Must be non-negative. ``parent = 0`` (the default)  refers to ``ref`` itself.\n\n        Returns\n        -------\n        Placeholder[Commit]\n            A placeholder for the commit created by the dispatched ``rev_parse`` API call.\n        \"\"\"\n\n        def rev_parse_op(client: LakeFSClient, **kwargs: Any) -&gt; Commit:\n            kwargs = unwrap_placeholders(kwargs)\n            return rev_parse(client, **kwargs)\n\n        p: Placeholder[Commit] = Placeholder()\n        op = partial(rev_parse_op, repository=repository, ref=ref, parent=parent)\n        self.files.append((op, p))\n        return p\n\n    def tag(self, repository: str, ref: str | Placeholder[Commit], tag: str) -&gt; str:\n        \"\"\"\n        Create a tag referencing a commit in a repository.\n\n        Parameters\n        ----------\n        repository: str\n            Name of the repository.\n        ref: str | Placeholder[Commit]\n            Commit SHA or placeholder for a commit object to which the new tag will point.\n        tag: str\n            Name of the tag to be created.\n\n        Returns\n        -------\n        str\n            The name of the requested tag.\n        \"\"\"\n\n        def tag_op(client: LakeFSClient, **kwargs: Any) -&gt; Ref:\n            kwargs = unwrap_placeholders(kwargs)\n            return create_tag(client, **kwargs)\n\n        self.files.append((partial(tag_op, repository=repository, ref=ref, tag=tag), tag))\n        return tag\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.commit","title":"commit","text":"<pre><code>commit(\n    repository: str, branch: str, message: str, metadata: dict[str, str] | None = None\n) -&gt; Placeholder[Commit]\n</code></pre> <p>Create a commit on a branch in a repository with a commit message and attached metadata.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>The repository to create the commit in.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>The name of the branch to commit on.</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>The commit message to attach to the newly created commit.</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Optional metadata to enrich the created commit with (author, e-mail, etc.).</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Placeholder[Commit]</code> <p>A placeholder for the commit created by the dispatched <code>commit</code> API call.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def commit(\n    self, repository: str, branch: str, message: str, metadata: dict[str, str] | None = None\n) -&gt; Placeholder[Commit]:\n    \"\"\"\n    Create a commit on a branch in a repository with a commit message and attached metadata.\n\n    Parameters\n    ----------\n    repository: str\n        The repository to create the commit in.\n    branch: str\n        The name of the branch to commit on.\n    message: str\n        The commit message to attach to the newly created commit.\n    metadata: dict[str, str] | None\n        Optional metadata to enrich the created commit with (author, e-mail, etc.).\n\n    Returns\n    -------\n    Placeholder[Commit]\n        A placeholder for the commit created by the dispatched ``commit`` API call.\n    \"\"\"\n    # bind all arguments to the client helper function, and then add it to the file-/callstack.\n    op = partial(\n        commit, repository=repository, branch=branch, message=message, metadata=metadata\n    )\n    p: Placeholder[Commit] = Placeholder()\n    self.files.append((op, p))\n    # return a placeholder for the commit.\n    return p\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.complete","title":"complete","text":"<pre><code>complete(commit: bool = True) -&gt; None\n</code></pre> <p>Finish the transaction by unwinding the file/versioning op stack via</p> <ol> <li>Committing or discarding in case of a file, and</li> <li>Conducting versioning operations using the file system's client.</li> </ol> <p>No operations happen and all files are discarded if <code>commit == False</code>, which is the case, e.g., if an exception happens in the context manager.</p> PARAMETER  DESCRIPTION <code>commit</code> <p>Whether to conduct operations queued in the transaction.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def complete(self, commit: bool = True) -&gt; None:\n    \"\"\"\n    Finish the transaction by unwinding the file/versioning op stack via\n\n    1. Committing or discarding in case of a file, and\n    2. Conducting versioning operations using the file system's client.\n\n    No operations happen and all files are discarded if ``commit == False``,\n    which is the case, e.g., if an exception happens in the context manager.\n\n    Parameters\n    ----------\n    commit: bool\n        Whether to conduct operations queued in the transaction.\n    \"\"\"\n    while self.files:\n        # fsspec base class calls `append` on the file, which means we\n        # have to pop from the left to preserve order.\n        f = self.files.popleft()\n        if isinstance(f, AbstractBufferedFile):\n            if commit:\n                f.commit()\n            else:\n                f.discard()\n        else:\n            # client helper + return value case.\n            op, retval = f\n            if commit:\n                result = op(self.fs.client)\n                # if the transaction member returns a placeholder,\n                # fill it with the result of the client helper.\n                if isinstance(retval, Placeholder):\n                    retval.set_value(result)\n\n    self.fs._intrans = False\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.create_branch","title":"create_branch","text":"<pre><code>create_branch(repository: str, name: str, source_branch: str, exist_ok: bool = True) -&gt; str\n</code></pre> <p>Create a branch <code>name</code> in a repository, branching off <code>source_branch</code>.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>Repository name.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the branch to be created.</p> <p> TYPE: <code>str</code> </p> <code>source_branch</code> <p>Name of the source branch that the new branch is created from.</p> <p> TYPE: <code>str</code> </p> <code>exist_ok</code> <p>Ignore creation errors if the branch already exists.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The requested branch name.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def create_branch(\n    self, repository: str, name: str, source_branch: str, exist_ok: bool = True\n) -&gt; str:\n    \"\"\"\n    Create a branch ``name`` in a repository, branching off ``source_branch``.\n\n    Parameters\n    ----------\n    repository: str\n        Repository name.\n    name: str\n        Name of the branch to be created.\n    source_branch: str\n        Name of the source branch that the new branch is created from.\n    exist_ok: bool\n        Ignore creation errors if the branch already exists.\n\n    Returns\n    -------\n    str\n        The requested branch name.\n    \"\"\"\n    op = partial(\n        create_branch,\n        repository=repository,\n        name=name,\n        source_branch=source_branch,\n        exist_ok=exist_ok,\n    )\n    self.files.append((op, name))\n    return name\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.merge","title":"merge","text":"<pre><code>merge(repository: str, source_ref: str, into: str) -&gt; None\n</code></pre> <p>Merge a branch into another branch in a repository.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>Name of the repository.</p> <p> TYPE: <code>str</code> </p> <code>source_ref</code> <p>Source reference containing the changes to merge. Can be a branch name or partial commit SHA.</p> <p> TYPE: <code>str</code> </p> <code>into</code> <p>Target branch into which the changes will be merged.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def merge(self, repository: str, source_ref: str, into: str) -&gt; None:\n    \"\"\"\n    Merge a branch into another branch in a repository.\n\n    Parameters\n    ----------\n    repository: str\n        Name of the repository.\n    source_ref: str\n        Source reference containing the changes to merge. Can be a branch name or partial commit SHA.\n    into: str\n        Target branch into which the changes will be merged.\n    \"\"\"\n    op = partial(merge, repository=repository, source_ref=source_ref, target_branch=into)\n    self.files.append((op, None))\n    return None\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.revert","title":"revert","text":"<pre><code>revert(repository: str, branch: str, parent_number: int = 1) -&gt; None\n</code></pre> <p>Revert a previous commit on a branch.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>Name of the repository.</p> <p> TYPE: <code>str</code> </p> <code>branch</code> <p>Branch on which the commit should be reverted.</p> <p> TYPE: <code>str</code> </p> <code>parent_number</code> <p>If there are multiple parents to a commit, specify to which parent the commit should be reverted. <code>parent_number = 1</code> (the default)  refers to the first parent commit of the current <code>branch</code> tip.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def revert(self, repository: str, branch: str, parent_number: int = 1) -&gt; None:\n    \"\"\"\n    Revert a previous commit on a branch.\n\n    Parameters\n    ----------\n    repository: str\n        Name of the repository.\n    branch: str\n        Branch on which the commit should be reverted.\n    parent_number: int\n        If there are multiple parents to a commit, specify to which parent the commit should be reverted.\n        ``parent_number = 1`` (the default)  refers to the first parent commit of the current ``branch`` tip.\n    \"\"\"\n\n    op = partial(revert, repository=repository, branch=branch, parent_number=parent_number)\n    self.files.append((op, None))\n    return None\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.rev_parse","title":"rev_parse","text":"<pre><code>rev_parse(repository: str, ref: str | Placeholder[Commit], parent: int = 0) -&gt; Placeholder[Commit]\n</code></pre> <p>Parse a given reference or any of its parents in a repository.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>Name of the repository.</p> <p> TYPE: <code>str</code> </p> <code>ref</code> <p>Commit SHA or commit placeholder object to resolve.</p> <p> TYPE: <code>str | Placeholder[Commit]</code> </p> <code>parent</code> <p>Optionally parse a parent of <code>ref</code> instead of <code>ref</code> itself as indicated by the number. Must be non-negative. <code>parent = 0</code> (the default)  refers to <code>ref</code> itself.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>Placeholder[Commit]</code> <p>A placeholder for the commit created by the dispatched <code>rev_parse</code> API call.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def rev_parse(\n    self, repository: str, ref: str | Placeholder[Commit], parent: int = 0\n) -&gt; Placeholder[Commit]:\n    \"\"\"\n    Parse a given reference or any of its parents in a repository.\n\n    Parameters\n    ----------\n    repository: str\n        Name of the repository.\n    ref: str | Placeholder[Commit]\n        Commit SHA or commit placeholder object to resolve.\n    parent: int\n        Optionally parse a parent of ``ref`` instead of ``ref`` itself as indicated by the number.\n        Must be non-negative. ``parent = 0`` (the default)  refers to ``ref`` itself.\n\n    Returns\n    -------\n    Placeholder[Commit]\n        A placeholder for the commit created by the dispatched ``rev_parse`` API call.\n    \"\"\"\n\n    def rev_parse_op(client: LakeFSClient, **kwargs: Any) -&gt; Commit:\n        kwargs = unwrap_placeholders(kwargs)\n        return rev_parse(client, **kwargs)\n\n    p: Placeholder[Commit] = Placeholder()\n    op = partial(rev_parse_op, repository=repository, ref=ref, parent=parent)\n    self.files.append((op, p))\n    return p\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.LakeFSTransaction.tag","title":"tag","text":"<pre><code>tag(repository: str, ref: str | Placeholder[Commit], tag: str) -&gt; str\n</code></pre> <p>Create a tag referencing a commit in a repository.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>Name of the repository.</p> <p> TYPE: <code>str</code> </p> <code>ref</code> <p>Commit SHA or placeholder for a commit object to which the new tag will point.</p> <p> TYPE: <code>str | Placeholder[Commit]</code> </p> <code>tag</code> <p>Name of the tag to be created.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The name of the requested tag.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def tag(self, repository: str, ref: str | Placeholder[Commit], tag: str) -&gt; str:\n    \"\"\"\n    Create a tag referencing a commit in a repository.\n\n    Parameters\n    ----------\n    repository: str\n        Name of the repository.\n    ref: str | Placeholder[Commit]\n        Commit SHA or placeholder for a commit object to which the new tag will point.\n    tag: str\n        Name of the tag to be created.\n\n    Returns\n    -------\n    str\n        The name of the requested tag.\n    \"\"\"\n\n    def tag_op(client: LakeFSClient, **kwargs: Any) -&gt; Ref:\n        kwargs = unwrap_placeholders(kwargs)\n        return create_tag(client, **kwargs)\n\n    self.files.append((partial(tag_op, repository=repository, ref=ref, tag=tag), tag))\n    return tag\n</code></pre>"},{"location":"reference/lakefs_spec/transaction/#lakefs_spec.transaction.unwrap_placeholders","title":"unwrap_placeholders","text":"<pre><code>unwrap_placeholders(kwargs: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Unwrap any placeholder values passed in a dictionary of keyword arguments.</p> Source code in <code>src/lakefs_spec/transaction.py</code> <pre><code>def unwrap_placeholders(kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Unwrap any placeholder values passed in a dictionary of keyword arguments.\"\"\"\n    return {k: v.unwrap() if isinstance(v, Placeholder) else v for k, v in kwargs.items()}\n</code></pre>"},{"location":"reference/lakefs_spec/util/","title":"util","text":"<p>Useful utilities for handling lakeFS URIs and results of lakeFS API calls.</p>"},{"location":"reference/lakefs_spec/util/#lakefs_spec.util.depaginate","title":"depaginate","text":"<pre><code>depaginate(\n    api: Callable[..., PaginatedApiResponse], *args: Any, **kwargs: Any\n) -&gt; Generator[Any, None, None]\n</code></pre> <p>Unwrap the responses from a paginated lakeFS API method into a generator.</p> PARAMETER  DESCRIPTION <code>api</code> <p>The lakeFS client API to call. Must return a paginated response with the <code>pagination</code> and <code>results</code> fields set.</p> <p> TYPE: <code>Callable[..., PaginatedApiResponse]</code> </p> <code>*args</code> <p>Positional arguments to pass to the API call.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the API call.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> YIELDS DESCRIPTION <code>Any</code> <p>The obtained API result objects.</p> Source code in <code>src/lakefs_spec/util.py</code> <pre><code>def depaginate(\n    api: Callable[..., PaginatedApiResponse], *args: Any, **kwargs: Any\n) -&gt; Generator[Any, None, None]:\n    \"\"\"\n    Unwrap the responses from a paginated lakeFS API method into a generator.\n\n    Parameters\n    ----------\n    api: Callable[..., PaginatedApiResponse]\n        The lakeFS client API to call. Must return a paginated response with the ``pagination`` and ``results`` fields set.\n    *args: Any\n        Positional arguments to pass to the API call.\n    **kwargs: Any\n        Keyword arguments to pass to the API call.\n\n    Yields\n    ------\n    Any\n        The obtained API result objects.\n    \"\"\"\n    while True:\n        resp = api(*args, **kwargs)\n        yield from resp.results\n        if not resp.pagination.has_more:\n            break\n        kwargs[\"after\"] = resp.pagination.next_offset\n</code></pre>"},{"location":"reference/lakefs_spec/util/#lakefs_spec.util.md5_checksum","title":"md5_checksum","text":"<pre><code>md5_checksum(lpath: str | os.PathLike[str], blocksize: int = 2 ** 22) -&gt; str\n</code></pre> <p>Calculate a local file's MD5 hash.</p> PARAMETER  DESCRIPTION <code>lpath</code> <p>The local path whose MD5 hash to calculate. Must be a file.</p> <p> TYPE: <code>str | PathLike[str]</code> </p> <code>blocksize</code> <p>Block size (in bytes) to use while reading in the file.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2 ** 22</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The file's MD5 hash value, as a string.</p> Source code in <code>src/lakefs_spec/util.py</code> <pre><code>def md5_checksum(lpath: str | os.PathLike[str], blocksize: int = 2**22) -&gt; str:\n    \"\"\"\n    Calculate a local file's MD5 hash.\n\n    Parameters\n    ----------\n    lpath: str | os.PathLike[str]\n        The local path whose MD5 hash to calculate. Must be a file.\n    blocksize: int\n        Block size (in bytes) to use while reading in the file.\n\n    Returns\n    -------\n    str\n        The file's MD5 hash value, as a string.\n    \"\"\"\n    with open(lpath, \"rb\") as f:\n        file_hash = hashlib.md5(usedforsecurity=False)\n        chunk = f.read(blocksize)\n        while chunk:\n            file_hash.update(chunk)\n            chunk = f.read(blocksize)\n    return file_hash.hexdigest()\n</code></pre>"},{"location":"reference/lakefs_spec/util/#lakefs_spec.util.parse","title":"parse","text":"<pre><code>parse(path: str) -&gt; tuple[str, str, str]\n</code></pre> <p>Parses a lakeFS URI in the form <code>lakefs://&lt;repo&gt;/&lt;ref&gt;/&lt;resource&gt;</code>.</p> PARAMETER  DESCRIPTION <code>path</code> <p>String path, needs to conform to the lakeFS URI format described above. The <code>&lt;resource&gt;</code> part can be the empty string; the leading <code>lakefs://</code> scheme may be omitted.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[str, str, str]</code> <p>A 3-tuple of repository name, reference, and resource name.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the path does not conform to the lakeFS URI format.</p> Source code in <code>src/lakefs_spec/util.py</code> <pre><code>def parse(path: str) -&gt; tuple[str, str, str]:\n    \"\"\"\n    Parses a lakeFS URI in the form ``lakefs://&lt;repo&gt;/&lt;ref&gt;/&lt;resource&gt;``.\n\n    Parameters\n    ----------\n    path: str\n        String path, needs to conform to the lakeFS URI format described above.\n        The ``&lt;resource&gt;`` part can be the empty string; the leading ``lakefs://`` scheme may be omitted.\n\n    Returns\n    -------\n    tuple[str, str, str]\n        A 3-tuple of repository name, reference, and resource name.\n\n    Raises\n    ------\n    ValueError\n        If the path does not conform to the lakeFS URI format.\n    \"\"\"\n\n    # First regex reflects the lakeFS repository naming rules:\n    # only lowercase letters, digits and dash, no leading dash, minimum 3, maximum 63 characters\n    # https://docs.lakefs.io/understand/model.html#repository\n    # Second regex is the branch: Only letters, digits, underscores and dash, no leading dash.\n    path_regex = re.compile(r\"(?:lakefs://)?([a-z0-9][a-z0-9\\-]{2,62})/(\\w[\\w\\-]*)/(.*)\")\n    results = path_regex.fullmatch(path)\n    if results is None:\n        raise ValueError(\n            f\"expected path with structure lakefs://&lt;repo&gt;/&lt;ref&gt;/&lt;resource&gt;, got {path!r}\"\n        )\n\n    repo, ref, resource = results.groups()\n    return repo, ref, resource\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Info</p> <p>We aim to provide additional tutorials in the future - contributions are welcome!</p> <ul> <li>Quickstart example: Using lakeFS-spec as a file system</li> <li>A fully-worked data science example: Using lakeFS-spec together with Pandas to train a classifier based on a public dataset and simulate additional data being collected</li> </ul>"},{"location":"tutorials/demo_data_science_project/","title":"Data Science with lakeFS-spec","text":"<pre><code>%pip install numpy pandas scikit-learn\n</code></pre> <pre>\n<code>Collecting numpy\n  Using cached numpy-1.26.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (61 kB)\nCollecting pandas\n  Using cached pandas-2.1.4-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (18 kB)\nCollecting scikit-learn\n  Using cached scikit_learn-1.3.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (11 kB)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages (from pandas) (2.8.2)\nRequirement already satisfied: pytz&gt;=2020.1 in /opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages (from pandas) (2023.3.post1)\nCollecting tzdata&gt;=2022.1 (from pandas)\n  Using cached tzdata-2023.3-py2.py3-none-any.whl (341 kB)\nCollecting scipy&gt;=1.5.0 (from scikit-learn)\n  Using cached scipy-1.11.4-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (60 kB)\nCollecting joblib&gt;=1.1.1 (from scikit-learn)\n  Using cached joblib-1.3.2-py3-none-any.whl.metadata (5.4 kB)\nCollecting threadpoolctl&gt;=2.0.0 (from scikit-learn)\n  Using cached threadpoolctl-3.2.0-py3-none-any.whl.metadata (10.0 kB)\nRequirement already satisfied: six&gt;=1.5 in /opt/hostedtoolcache/Python/3.11.7/x64/lib/python3.11/site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas) (1.16.0)\nUsing cached numpy-1.26.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (18.2 MB)\nUsing cached pandas-2.1.4-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (12.2 MB)\nUsing cached scikit_learn-1.3.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (10.9 MB)\nUsing cached joblib-1.3.2-py3-none-any.whl (302 kB)\nUsing cached scipy-1.11.4-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (36.4 MB)\nUsing cached threadpoolctl-3.2.0-py3-none-any.whl (15 kB)\nInstalling collected packages: tzdata, threadpoolctl, numpy, joblib, scipy, pandas, scikit-learn\nSuccessfully installed joblib-1.3.2 numpy-1.26.2 pandas-2.1.4 scikit-learn-1.3.2 scipy-1.11.4 threadpoolctl-3.2.0 tzdata-2023.3\nNote: you may need to restart the kernel to use updated packages.\n</code>\n</pre> <p>Also install an appropriate lakeFS-spec version, which can be either the latest release from PyPI via <code>pip install --upgrade lakefs-spec</code>, or the development version from GitHub via <code>pip install git+https://github.com/aai-institute/lakefs-spec.git</code>.</p> <pre><code>import os\nimport urllib.request\n\nurllib.request.urlretrieve(\n    \"https://raw.githubusercontent.com/aai-institute/lakefs-spec/main/docs/tutorials/.lakectl.yaml\",\n    os.path.expanduser(\"~/.lakectl.yaml\"),\n)\n</code></pre> <pre>\n<code>('/home/runner/.lakectl.yaml', &lt;http.client.HTTPMessage at 0x7f3efcf292d0&gt;)</code>\n</pre> <p>We can now instantiate the <code>LakeFSFileSystem</code> with the credentials we just downloaded. Alternatively, we could have passed the credentials directly in the code. It is important that the credentials are available at the time of filesystem instantiation.</p> <pre><code>from lakefs_spec import LakeFSFileSystem\n\nfs = LakeFSFileSystem()\n\nREPO_NAME = \"weather\"\n</code></pre> <p>We will create a repository using a helper function provided by lakeFS-spec. If you have already created one in the UI, make sure to set the <code>REPO_NAME</code> variable accordingly in the cell directly above.</p> <pre><code>from lakefs_spec.client_helpers import create_repository\n\nrepo = create_repository(client=fs.client, name=REPO_NAME, storage_namespace=f\"local://{REPO_NAME}\")\n</code></pre> <pre><code>outfile, _ = urllib.request.urlretrieve(\n    \"https://archive-api.open-meteo.com/v1/archive?latitude=52.52&amp;amp;longitude=13.41&amp;amp;start_date=2010-01-01&amp;amp;end_date=2010-12-31&amp;amp;hourly=temperature_2m,relativehumidity_2m,rain,pressure_msl,surface_pressure,cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,windspeed_10m,windspeed_100m,winddirection_10m,winddirection_100m\"\n)\n</code></pre> <p>The data is in JSON format. Therefore, we need to wrangle the data a bit to make it usable. But first, we will upload it to our lakeFS instance.</p> <pre><code>NEW_BRANCH_NAME = \"transform-raw-data\"\n\nwith fs.transaction as tx:\n    fs.put(outfile, f\"{REPO_NAME}/{NEW_BRANCH_NAME}/weather-2010.json\")\n    tx.commit(repository=REPO_NAME, branch=NEW_BRANCH_NAME, message=\"Add 2010 weather data\")\n</code></pre> <p>You can inspect this commit by selecting the <code>transform-raw-data</code> branch, and navigating to the Commits tab.</p> <pre><code>import json\n\nimport pandas as pd\n\n\ndef transform_json_weather_data(filepath):\n    if hasattr(filepath, \"close\") and hasattr(filepath, \"tell\"):\n        data = json.load(filepath)\n    else:\n        with open(filepath, \"r\") as f:\n            data = json.load(f)\n\n    df = pd.DataFrame.from_dict(data[\"hourly\"])\n    df.time = pd.to_datetime(df.time)\n    df[\"is_raining\"] = df.rain &amp;gt; 0\n    df[\"is_raining_in_1_day\"] = df.is_raining.shift(24).astype(bool)\n    df = df.dropna()\n    return df\n\n\ndf = transform_json_weather_data(outfile)\ndf.head(5)\n</code></pre> time temperature_2m relativehumidity_2m rain pressure_msl surface_pressure cloudcover cloudcover_low cloudcover_mid cloudcover_high windspeed_10m windspeed_100m winddirection_10m winddirection_100m is_raining is_raining_in_1_day 0 2010-01-01 00:00:00 -2.6 88 0.0 996.9 992.1 100 100 97 75 16.0 27.2 54 58 False True 1 2010-01-01 01:00:00 -2.7 88 0.0 996.4 991.6 100 99 96 49 16.3 28.0 55 58 False True 2 2010-01-01 02:00:00 -2.7 88 0.0 996.2 991.4 100 96 94 60 16.3 27.5 55 58 False True 3 2010-01-01 03:00:00 -2.7 88 0.0 996.1 991.3 100 97 96 83 15.4 26.6 53 57 False True 4 2010-01-01 04:00:00 -2.7 88 0.0 996.0 991.2 100 92 98 82 14.8 25.6 47 52 False True <p>Next, we save this data as a CSV file into the main branch. When the transaction commit helper is called, the newly put CSV file is committed. You can verify the saving worked in the lakeFS UI in your browser by switching to the commits tab of the <code>main</code> branch.</p> <pre><code>with fs.transaction as tx:\n    df.to_csv(f\"lakefs://{REPO_NAME}/main/weather_2010.csv\")\n    tx.commit(repository=REPO_NAME, branch=\"main\", message=\"Update weather data\")\n</code></pre> <pre><code>import sklearn.model_selection\n\nmodel_data = df.drop(\"time\", axis=1)\n\ntrain, test = sklearn.model_selection.train_test_split(model_data, random_state=7)\n</code></pre> <p>We save these train and test datasets into a new <code>training</code> branch. If the branch does not exist yet, as in this case, it is implicitly created by default. You can control this behaviour with the <code>create_branch_ok</code> flag when initializing the <code>LakeFSFileSystem</code>. By default, <code>create_branch_ok</code> is set to <code>True</code>, so we need to only set <code>fs = LakeFSFileSystem()</code> to enable implicit branch creation.</p> <pre><code>TRAINING_BRANCH = \"training\"\n\nwith fs.transaction as tx:\n    train.to_csv(f\"lakefs://{REPO_NAME}/{TRAINING_BRANCH}/train_weather.csv\")\n    test.to_csv(f\"lakefs://{REPO_NAME}/{TRAINING_BRANCH}/test_weather.csv\")\n    tx.commit(\n        repository=REPO_NAME,\n        branch=TRAINING_BRANCH,\n        message=\"Add train-test split of 2010 weather data\",\n    )\n</code></pre> <p>Let's check the shape of train and test data. Later on, we will get back to this data version and reproduce the results of the experiment.</p> <pre><code>print(f\"Initial train data shape: {train.shape}\")\nprint(f\"Initial test data shape: {test.shape}\")\n</code></pre> <pre>\n<code>Initial train data shape: (6570, 15)\nInitial test data shape: (2190, 15)\n</code>\n</pre> <p>We now proceed to train a decision tree classifier and evaluate it on the test set:</p> <pre><code>from sklearn.tree import DecisionTreeClassifier\n\ndependent_variable = \"is_raining_in_1_day\"\n\nmodel = DecisionTreeClassifier(random_state=7)\n\nx_train, y_train = train.drop(dependent_variable, axis=1), train[dependent_variable].astype(bool)\nx_test, y_test = test.drop(dependent_variable, axis=1), test[dependent_variable].astype(bool)\n\nmodel.fit(x_train, y_train)\n\ntest_acc = model.score(x_test, y_test)\nprint(f\"Test accuracy: {test_acc:.2%}\")\n</code></pre> <pre>\n<code>Test accuracy: 87.31%\n</code>\n</pre> <pre><code>outfile, _ = urllib.request.urlretrieve(\n    \"https://archive-api.open-meteo.com/v1/archive?latitude=52.52&amp;amp;longitude=13.41&amp;amp;start_date=2020-01-01&amp;amp;end_date=2020-12-31&amp;amp;hourly=temperature_2m,relativehumidity_2m,rain,pressure_msl,surface_pressure,cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,windspeed_10m,windspeed_100m,winddirection_10m,winddirection_100m\"\n)\n\nnew_data = transform_json_weather_data(outfile)\n\nwith fs.transaction as tx:\n    new_data.to_csv(f\"lakefs://{REPO_NAME}/main/weather_2020.csv\")\n    tx.commit(repository=REPO_NAME, branch=\"main\", message=\"Add 2020 weather data\")\n\n# Remove leftover temporary files from previous `urlretrieve` calls\nurllib.request.urlcleanup()\n</code></pre> <p>Let's concatenate the old data and the new data, create a new train-test split, and push the updated files to lakeFS:</p> <pre><code>new_data = new_data.drop(\"time\", axis=1)\nfull_data = pd.concat([new_data, train, test])\n\ntrain_df, test_df = sklearn.model_selection.train_test_split(full_data, random_state=7)\n\nprint(f\"Updated train data shape: {train_df.shape}\")\nprint(f\"Updated test data shape: {test_df.shape}\")\n\nwith fs.transaction as tx:\n    train_df.to_csv(f\"lakefs://{REPO_NAME}/{TRAINING_BRANCH}/train_weather.csv\")\n    test_df.to_csv(f\"lakefs://{REPO_NAME}/{TRAINING_BRANCH}/test_weather.csv\")\n    tx.commit(\n        repository=REPO_NAME,\n        branch=TRAINING_BRANCH,\n        message=\"Add train-test split of 2010 and 2020 data\",\n    )\n</code></pre> <pre>\n<code>Updated train data shape: (13158, 15)\nUpdated test data shape: (4386, 15)\n</code>\n</pre> <p>Now, we train the model on the new data and validate on the new test data.</p> <pre><code>x_train, y_train = (\n    train_df.drop(dependent_variable, axis=1),\n    train_df[dependent_variable].astype(bool),\n)\nx_test, y_test = test_df.drop(dependent_variable, axis=1), test_df[dependent_variable].astype(bool)\n\nmodel.fit(x_train, y_train)\n\ntest_acc = model.score(x_test, y_test)\n\nprint(f\"Test accuracy: {test_acc:.2%}\")\n</code></pre> <pre>\n<code>Test accuracy: 82.67%\n</code>\n</pre> <pre><code>from lakefs_spec.client_helpers import rev_parse\n\n# parent is the parent number of a commit relative to HEAD (the latest commit, for which parent = 0).\nprevious_commit = rev_parse(fs.client, REPO_NAME, TRAINING_BRANCH, parent=1)\nfixed_commit_id = previous_commit.id\nprint(fixed_commit_id)\n</code></pre> <pre>\n<code>751af8bbc1e50d4237574181cc3e026b94932c765d4580c97b00b5e83a4bad46\n</code>\n</pre> <p>Let's check whether we managed to get the initial train and test data with this commit SHA, checking equality to the initial data:</p> <pre><code>orig_train = pd.read_csv(f\"lakefs://{REPO_NAME}/{fixed_commit_id}/train_weather.csv\", index_col=0)\norig_test = pd.read_csv(f\"lakefs://{REPO_NAME}/{fixed_commit_id}/test_weather.csv\", index_col=0)\n\nprint(f\"Is the pulled training data equal to the local training data? {train.equals(orig_train)}\")\nprint(f\"Is the pulled test data equal to the local test data? {test.equals(orig_test)}\")\n</code></pre> <pre>\n<code>Is the pulled training data equal to the local training data? True\nIs the pulled test data equal to the local test data? True\n</code>\n</pre> <p>Let's train and validate the model again based on the redownloaded data and see if we manage to reproduce the initial accuracy.</p> <pre><code>x_train, y_train = train.drop(dependent_variable, axis=1), train[dependent_variable].astype(bool)\nx_test, y_test = test.drop(dependent_variable, axis=1), test[dependent_variable].astype(bool)\n\nmodel.fit(x_train, y_train)\n\ntest_acc = model.score(x_test, y_test)\n\nprint(f\"Test accuracy: {test_acc:.2%}\")\n</code></pre> <pre>\n<code>Test accuracy: 87.31%\n</code>\n</pre> <pre><code>with fs.transaction as tx:\n    # the `tag` result is simply the tag name, in this case 'train-test-split-2010'.\n    tag = tx.tag(repository=REPO_NAME, ref=fixed_commit_id, tag=\"train-test-split-2010\")\n</code></pre> <p>Now we can access the specific files with the semantic tag. Both the <code>fixed_commit_id</code> and <code>tag</code> reference the same version <code>ref</code> in lakeFS, whereas a branch name always points to the latest version on that respective branch.</p> <pre><code>train_from_commit = pd.read_csv(\n    f\"lakefs://{REPO_NAME}/{fixed_commit_id}/train_weather.csv\", index_col=0\n)\ntrain_from_tag = pd.read_csv(f\"lakefs://{REPO_NAME}/{tag}/train_weather.csv\", index_col=0)\n</code></pre> <p>We can verify this by comparing the <code>DataFrame</code>s. We see that the <code>train_from_commit</code> and <code>train_from_tag</code> are equal.</p> <pre><code>print(\n    f\"Is the data tagged {tag!r} equal to the data in commit {fixed_commit_id[:8]}? {train_from_commit.equals(train_from_tag)}\"\n)\n</code></pre> <pre>\n<code>Is the data tagged 'train-test-split-2010' equal to the data in commit 751af8bb? True\n</code>\n</pre>"},{"location":"tutorials/demo_data_science_project/#data-science-with-lakefs-spec","title":"Data Science with lakeFS-spec","text":"<p>In this notebook, we will complete a small end-to-end data science tutorial that employs lakeFS-spec for data versioning. We will use versioned weather data to train a decision tree classifier to predict whether it is raining tomorrow given the current weather.</p> <p>We will do the following:</p> <ul> <li>Environment setup</li> <li>LakeFS setup</li> <li>Authenticating with the lakeFS server</li> <li>Data ingestion via transactions</li> <li>Model training</li> <li>Updating data and retraining a model</li> <li>Accessing data versions and reproducing experiments</li> <li>Using tags for semantic versioning</li> </ul> <p>Local Execution</p> <p>If you want to execute the code in this tutorial as a Jupyter notebook yourself, download the <code>demo_data_science_project.py</code> file from the lakeFS-spec repository.</p> <p>You can then convert the Python file to a notebook using Jupytext using the following command: <code>jupytext --to notebook demo_data_science_project.py</code>.</p> <p>This tutorial assumes that you have installed lakeFS-spec in a virtual environment, and that you have followed the quickstart guide to set up a local lakeFS instance.</p>"},{"location":"tutorials/demo_data_science_project/#environment-setup","title":"Environment setup","text":"<p>Install the necessary libraries for this notebook on the environment you have just created:</p>"},{"location":"tutorials/demo_data_science_project/#lakefs-setup","title":"lakeFS Setup","text":"<p>With Docker Desktop or a similar runtime running set up lakeFS by executing the following <code>docker run</code> command (from the lakeFS quickstart) in your console:</p> <pre><code>docker run --name lakefs --pull always --rm --publish 8000:8000 treeverse/lakefs:latest run --quickstart\n</code></pre> <p>You find the authentication credentials in the terminal output. The default address for the local lakeFS GUI is http://localhost:8000/.</p>"},{"location":"tutorials/demo_data_science_project/#authenticating-with-the-lakefs-server","title":"Authenticating with the lakeFS server","text":"<p>There are multiple ways to authenticate with lakeFS from Python code. In this tutorial, we choose the YAML file configuration. By executing the cell below, you will download a YAML file containing the default lakeFS quickstart credentials and server URL to your user directory.</p>"},{"location":"tutorials/demo_data_science_project/#data-ingestion","title":"Data Ingestion","text":"<p>Now it's time to get some data. We will use the Open-Meteo API, where we can pull weather data from an API for free (as long as we are non-commercial) and without an API token.</p> <p>For training our toy model, we download the full weather data of Munich for the year 2010:</p>"},{"location":"tutorials/demo_data_science_project/#upload-a-file-using-transactions","title":"Upload a file using transactions","text":"<p>lakeFS works similar to <code>git</code> as a versioning system. You can create commits that contain specific changes to the data. You can also work with branches to create your own isolated view of the data independently of your colleagues. Every commit (on any branch) is identified by a commit SHA. This SHA can be used to programmatically interact with specific states of your data and enables logging of the specific data versions used to create a certain model.</p> <p>To easily carry out versioning operations while uploading files, you can use transactions. A transaction is a context manager that keeps track of all files that were uploaded in its scope, as well as all versioning operations happening between file uploads. All operations are deferred to the end of the transaction, and are executed sequentially on completion.</p> <p>To create a commit after a file upload, you can run the following transaction:</p>"},{"location":"tutorials/demo_data_science_project/#data-transformation","title":"Data Transformation","text":"<p>Now let's transform the data for our use case. We put the transformation into a function to be able to reuse it later.</p> <p>In this notebook, we use a simple toy model to predict whether it is raining at the same time tomorrow given weather data from right now.</p> <p>We will skip a lot of possible feature engineering and other data science aspects in order to focus more on the application of the <code>LakeFSFileSystem</code>.</p>"},{"location":"tutorials/demo_data_science_project/#training-the-initial-weather-model","title":"Training the initial weather model","text":"<p>First we will do a train-test split:</p>"},{"location":"tutorials/demo_data_science_project/#updating-data-and-retraining-the-model","title":"Updating data and retraining the model","text":"<p>Until now, we only have used data from 2010. Let's download additional 2020 data, transform it, and save it to lakeFS.</p>"},{"location":"tutorials/demo_data_science_project/#accessing-data-versions-through-commits-and-reproducing-experiments","title":"Accessing data versions through commits and reproducing experiments","text":"<p>If we need to go to our initial data and reproduce the first experiment (the model trained on the 2010 data with its initial accuracy), we can go back in the commit history of the <code>training</code> branch and select the appropriate commit data snapshot. Since we have created multiple commits on the same branch already, we will address different data versions by their commit SHAs.</p> <p>To obtain the actual commit SHA from a branch, we have multiple options. Manually, we could go into the lakeFS UI, select the training branch, and navigate to the Commits tab. There, we take the parent of the previous commit, titled <code>Add train-test split of 2010 weather data</code>, and copy its revision SHA (also called <code>ID</code>).</p> <p>In code, we can use a versioning helper called <code>rev_parse</code> to obtain commit SHAs for different revisions on the <code>training</code> branch.</p>"},{"location":"tutorials/demo_data_science_project/#using-tags-instead-of-commit-shas-for-semantic-versioning","title":"Using tags instead of commit SHAs for semantic versioning","text":"<p>The above method for data versioning works great when you have experiment tracking tools to store and retrieve the commit SHA in automated pipelines. But it can be tedious to retrieve in manual prototyping. We can make selected versions of the dataset more accessible with semantic versioning by attaching a human-interpretable tag to a specific commit SHA.</p> <p>Creating a tag is easiest when done inside a transaction, just like the files we already uploaded. To do this, simply call <code>tx.tag</code> on the transaction and supply the repository name, the commit SHA to tag, and the intended tag name. Tags are immutable once created, so attempting to tag two different commits with the same name will result in an error.</p>"}]}