# Reasons to use `lakefs-spec`

Among others, there are two main reasons to use `lakefs-spec` over raw client interactions:

## Integration with `fsspec`-powered Python data science libraries

Some projects, including `pandas`, `polars`, and `pyspark`, use `fsspec` to abstract I/O into a file-system paradigm.
Registering other file systems is as easy as running a hook in `setuptools` (or `poetry`, depending on your preference)
at build time.

`lakefs-spec` itself is registered as the default file system for the `lakefs` protocol in the official `fsspec` registry,
so all you have to do is to `pip install lakefs-spec` to start using it.

With it, reading and writing data in a versioned manner is supported natively, for example as such:

```python
import pandas as pd

storage_options={
    "host": "localhost:8000",
    "username": "username",
    "password": "password",
}

df = pd.read_parquet('lakefs://quickstart/main/lakes.parquet', storage_options=storage_options)
```

With more advanced methods in `lakefs-spec` such as config file instantiation and environment variable setting,
you can even instantiate the file system without any arguments and rely on automated setup.

## Setting up lakeFS automations after file operations

Dealing with the raw lakeFS API client in interactions with a lakeFS instance can be cumbersome, for reasons like
weirdness in autogenerated classes and docstrings, API models instead of raw Python types, and unintuitive keyword
arguments.

Using `lakefs-spec` you can interact with your lakeFS instance in a file-centric way. Each file operation is mapped to
one (or more) client API calls, which are completely abstracted away from the user and hidden behind the standard `fsspec`
APIs, which allow for accurate typing.

Since lakeFS is a data versioning tool and not only an object store, you should be able to carry out its versioning operations after
file operations. `lakefs-spec` solves this by exposing a hook mechanism to optionally register and run user code after each
completed file system method.

A concrete example of this is creating lakeFS commits after a successful file upload.
Commits provide a snapshot of a lakeFS repository, similarly to version control systems like git.

```python
from lakefs_client.client import LakeFSClient

from lakefs_spec import LakeFSFileSystem
from lakefs_spec.client_helpers import commit
from lakefs_spec.hooks import FSEvent, HookContext

def create_commit_on_put(client: LakeFSClient, ctx: HookContext) -> None:
    message = f"Add file {ctx.resource}"
    commit(client, repository=ctx.repository, branch=ctx.ref, message=message)

fs = LakeFSFileSystem()

fs.register_hook(FSEvent.PUT_FILE, create_commit_on_put)

# creates a commit with the message "Add file my-file.txt" after the file put.
fs.put_file("my-file.txt", "my-repo/my-branch/my-file.txt")
```

The other major convenience provided by `lakefs-spec` for creating lakeFS automations is the `lakefs_spec.client_helpers` module,
which contains useful lakeFS operations (creating commits etc.) implemented as Python functions, and can be used as building blocks for hooks.
